#' Create an empty pedigree
#'
#' \code{create_pedFile} initializes an empty data frame with all of the fields required by \code{sim_ped} to simulate a pedigree.
#'
#' @return An empty data frame with all fields required by \code{sim_ped} to generate a pedigree.
#' @keywords internal
#'
create_pedFile = function(){
  data.frame(FamID = numeric(),
             ID = numeric(),
             sex = numeric(),
             dadID = numeric(),
             momID = numeric(),
             affected = numeric(),
             DA1 = numeric(),
             DA2 = numeric(),
             birthYr = numeric(),
             onsetYr = numeric(),
             deathYr = numeric(),
             RR = numeric(),
             available = numeric(),
             Gen = numeric(),
             do_sim = numeric(),
             stringsAsFactors=FALSE)
}

#' Create a new mate
#'
#' Create new mating partner in pedigree.
#'
#' @inheritParams sim_RVped
#' @param partner_info  Data.frame with 1 row. All pedigree information for the individual requiring a new mate, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param last_id Numeric.  The last id used in the pedigree.
#' @param RV_founder Logical. If \code{RV_founder = TRUE}, then at least 1 founder has introduced the causal variant to the pedigree. If \code{RV_founder = FALSE} then the variant has not yet been introduced to the pedigree.
#'
#' @return \code{new_mate_info} the pedigree information for the new mate.
#' @return \code{last_id} the updated value of last_id after adding the new mate.
#' @return \code{RV_founder} a true/false value indicating if at least 1 founder has introduced the RV.
#'
#' @keywords internal
#'
#'
create_mate = function(partner_info, last_id,
                       GRR, prob_causalRV,
                       single_founderEntry, RV_founder){
  new_mate_info <- data.frame(FamID = partner_info$FamID,
                             ID = last_id+1,
                             sex = abs(partner_info$sex - 1),
                             dadID = NA,
                             momID = NA,
                             affected = 0,
                             DA1 = NA,
                             DA2 = NA,
                             birthYr = NA,
                             onsetYr = NA,
                             deathYr = NA,
                             RR = NA,
                             available = 0,
                             Gen = partner_info$Gen,
                             do_sim = 0,
                             stringsAsFactors=FALSE)
  #if RV founder already obtained and single_founderEntry selected
  #then new parent cannot introduce RV
  if(single_founderEntry & RV_founder){
    new_mate_info$DA1 <- 0
    new_mate_info$DA2 <- 0
    new_mate_info$RR <- 1
    RVfounder <- RV_founder
  } else {
    new_mate_info[1, c(7:8)] <- sample(x = c(0, ifelse(runif(1) <= prob_causalRV, 1, 0)),
                                       size = 2, replace = F)
    new_mate_info$RR <- ifelse(sum(new_mate_info$DA1, new_mate_info$DA2) == 0,
                                1, GRR)
    RVfounder <- ifelse(any(new_mate_info[1, c(7:8)] == 1), TRUE, FALSE)
  }

  mate_return <- list(new_mate_info, last_id + 1, RVfounder)
  return(mate_return)
}

#' Create a new offspring
#'
#' Create new offspring in pedigree.
#'
#' @inheritParams create_mate
#' @inheritParams sim_RVped
#' @param dad_info Data.frame with 1 row. All pedigree information of offspring's father, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param mom_info Data.frame with 1 row. All pedigree information of offspring's mother, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param byear The birth year of offspring.
#'
#' @return new_child_info the pedigree information for the new child
#' @return last_id the updated value of last_id after adding new offspring
#'
#' @keywords internal
#'
#' @importFrom stats runif
#'
create_offspring = function(dad_info, mom_info, byear, last_id, GRR){
  new_child_info <- data.frame(FamID = dad_info$FamID,
                              ID = last_id + 1,
                              sex = round(runif(1)),
                              dadID = dad_info$ID,
                              momID = mom_info$ID,
                              affected = 0,
                              DA1 = sample(x = c(dad_info$DA1, dad_info$DA2), size = 1),
                              DA2 = sample(x = c(mom_info$DA1, mom_info$DA2), size = 1),
                              birthYr = byear,
                              onsetYr = NA,
                              deathYr = NA,
                              RR = NA,
                              available = 1,
                              Gen = dad_info$Gen + 1,
                              do_sim = 1,
                              stringsAsFactors=FALSE)
  new_child_info$RR <- ifelse(sum(new_child_info$DA1, new_child_info$DA2) == 0,
                              1, GRR)
  child_return <- list(new_child_info, last_id+1)
  return(child_return)
}


#' Simulate a nuclear family from a single founder
#'
#' Simulate all life events for an individual and create a nuclear family, when appropriate.
#'
#' @param found_info Data.frame with 1 row. All pedigree information for the founder, must contain all fields generated by \code{\link{create_pedFile}}.
#' @inheritParams create_mate
#' @inheritParams sim_RVped
#'
#' @keywords internal
#' @return A pedigree with updated life events for the founder, and
#' additional information for mate and offspring, when offspring are generated.
#'
sim_nFam = function(found_info, stop_year, last_id,
                    hazard_rates, birth_range, NB_params,
                    GRR, prob_causalRV,
                    single_founderEntry, RV_founder){

  nfam_ped <- found_info

  #Simulate life steps for founder
  sim_years <- sim_lifeEvents(hazard_rates,
                              birth_range, NB_params,
                              RR = found_info$RR,
                              YOB = found_info$birthYr)


  # update disease status and onset year if onset occured prior to stop_year
  if (is.element("Onset", names(sim_years))) {
    o_year <- as.numeric(sim_years[which(names(sim_years) == "Onset")])
    if (o_year <= stop_year) {
      nfam_ped$affected <- 1
      nfam_ped$onsetYr <- o_year
    } else {
      nfam_ped$affected <- 0
      nfam_ped$onsetYr <- NA
    }
  } else {
    nfam_ped$affected <- 0
    nfam_ped$onsetYr <- NA
  }

  #set the year of death if it occurs before stop_year
  d_year <- as.numeric(sim_years[which(names(sim_years) == "Death")])
  if (d_year <= stop_year) {
    nfam_ped$deathYr <- d_year
  }

  #store the birth years of each child
  birth_events <- as.numeric(sim_years[which(names(sim_years) == "Child" &
                                               sim_years <= stop_year)])

  if (length(birth_events) > 0) {
    #add a mate
    new_mate <- create_mate(partner_info = nfam_ped[1,], last_id,
                            GRR, prob_causalRV,
                            single_founderEntry, RV_founder)
    nfam_ped <- rbind(nfam_ped, new_mate[[1]])
    last_id <- new_mate[[2]]
    RVfounder <- new_mate[[3]]

    #store info for mom and dad
    dad <- nfam_ped[which(nfam_ped$sex == 0), ]
    mom <- nfam_ped[which(nfam_ped$sex == 1), ]

    for (k in 1:length(birth_events)) {
      #add child
      new_child <- create_offspring(dad_info = dad, mom_info = mom,
                                    byear = birth_events[k], last_id, GRR)
      nfam_ped <- rbind(nfam_ped, new_child[[1]])
      last_id <- new_child[[2]]
    }
  } else {
    RVfounder <- RV_founder
  }

  #set do_sim to 0 for individual whose life events we just simulated
  nfam_ped$do_sim[1] = 0

  sim_fam_return = list(nfam_ped, last_id, RVfounder)
  return(sim_fam_return)
}

#' Simulate a pedigree
#'
#' Please note the distinction between \code{sim_ped} and \code{sim_RVped}.  Pedigrees simulated using \code{sim_ped} do not account for study design.  To simulate a pedigree ascertained to contain multiple family members affected by a disease please use \code{\link{sim_RVped}}.
#'
#'
#' By assumption, all pedigrees are segregating a rare variant, which is rare enough to have been introduced by exactly one founder.  \code{sim_ped} starts simulating the pedigree by generating the birth year for this founder, uniformly between the years specified by \code{founder_byears}.  Next, all life events are simulated for the founder via \code{\link{sim_lifeEvents}}.  Possible life events include: reproduction, disease onset, and death.  We only allow disease onset to occur once, i.e. no remission.  Computationally, this implies that after an individual has experienced disease onset, their waiting time to death is always simulated using the age-specific mortality rates for the \emph{affected} population (i.e. the second column specified in \code{death_hazard}).  Life events for individuals who have inherited the rare variant are simulated such that their relative-risk of developing disease is \code{GRR}, according to a proportional hazards model. For all individuals who have not inherited the rare variant the relative-risk of disease onset is 1.  Any life events that occur after \code{stop_year} are censored.
#'
#' The rare variant is transmitted to any offspring of the founder according to Mendel's laws, and the process of simulating life events is repeated for offspring, recursively, until no additional offspring are produced.
#'
#'
#' @inheritParams sim_RVped
#'
#' @return The simulated pedigree.
#' @export
#' @importFrom stats runif
#'
#' @references OUR MANUSCRIPT
#' @references Ken-Ichi Kojima, Therese M. Kelleher. (1962), \emph{Survival of Mutant Genes}. The American Naturalist 96, 329-346.
#'
#' @section See Also:
#' \code{\link{sim_RVped}}
#'
#' @examples
#' data(AgeSpecific_Hazards)
#'
#' my_HR <- new.hazard(partition = seq(0, 100, by = 1),
#'                     hazardDF = AgeSpecific_Hazards)
#'
#' #Simulate a random pedigree
#' set.seed(22)
#' ex_ped <- sim_ped(hazard_rates = my_HR,
#'                   GRR = 5, prob_causalRV = 1,
#'                   FamID = 1,
#'                   founder_byears = c(1900, 1910),
#'                   stop_year = 2015)
#'
#' #Plot pedigree with the kinship2 package
#' library(kinship2)
#'
#' #Define pedigree and pass to plot function
#' RV_status <- ex_ped$DA1 + ex_ped$DA2
#' Affected  <- ex_ped$affected
#'
#' ex_pedigree <- pedigree(id = ex_ped$ID,
#'                         dadid = ex_ped$dadID,
#'                         momid = ex_ped$momID,
#'                         sex = ex_ped$sex + 1,
#'                         affected = cbind(Affected, RV_status))
#' plot(ex_pedigree)
#' pedigree.legend(ex_pedigree, location = "bottomleft",  radius = 0.25)
#'
sim_ped = function(hazard_rates, GRR, prob_causalRV,
                   FamID, founder_byears, stop_year,
                   single_founderEntry = TRUE,
                   birth_range = c(18, 45),
                   NB_params = c(2, 4/7)){

  #initialize a data frame to store all the necessary info for the ped file
  fam_ped <- create_pedFile()


  #randomly generate birth year and sex for the founder carrying the RV,
  #and fill in all other fields with the appropriate info
  fam_ped[1,] <- c(FamID,            #family ID
                   1,                #RV status
                   round(runif(1)),  #sex
                   NA, NA,           #dadID and #momID
                   NA,               #affected status
                   NA, NA,             #alleles 1 and 2,
                   round(runif(1, min = founder_byears[1],
                               max = founder_byears[2])), #birth year
                   NA, NA,           #onset and death years
                   NA,               #RR of developing disease
                   1, 1,             #availablilty and generation no
                   1)                # do_sim

  fam_ped[1, c(7:8)] <- sample(x = c(0, ifelse(runif(1) <= prob_causalRV, 1, 0)),
                               size = 2, replace = F)
  fam_ped$RR[1] <- ifelse(1 %in% fam_ped[1, c(7:8)], GRR, 1)
  RVfounder <- ifelse(fam_ped$RR[1] == 1, F, T)

  last_id <- 1
  last_gen <- 1

  #store the ID of individuals for whom we need to simulate life events
  re_sim <- fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last_gen)]
  while (length(re_sim) > 0) {
    for (k in 1:length(re_sim)) {
      newKin <- sim_nFam(found_info = fam_ped[which(fam_ped$ID == re_sim[k]),],
                         stop_year, last_id,
                         hazard_rates, birth_range, NB_params,
                         GRR, prob_causalRV,
                         single_founderEntry, RV_founder = RVfounder)

      #replace individual by their simulated self and add family members when necessary
      fam_ped <- rbind(fam_ped[-which(fam_ped$ID == re_sim[k]), ],
                       newKin[[1]])

      last_id <- newKin[[2]]
      RVfounder <- newKin[[3]]
    }
    last_gen <- max(fam_ped$Gen)
    re_sim <- fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last_gen)]
  }

  return(fam_ped[, c(1:14)])
}

#' Choose a proband from the disease-affected relatives in a pedigree
#'
#' @param ped Pedigree simulated by \code{sim_ped}.
#' @inheritParams sim_RVped
#'
#' @return Pedigree with proband selected.
#' @keywords internal
#'
choose_proband = function(ped, num_affected, ascertain_span){
  #initialize proband ID variable
  ped$proband <- 0

  #Gather info on affecteds
  A_ID <- ped[which(ped$affected == 1),
              which(colnames(ped) %in% c("onsetYr", "ID", "proband"))]
  A_ID <- A_ID[order(A_ID$onsetYr), ]
  A_ID <- A_ID[which(A_ID$onsetYr <= ascertain_span[2]), ]
  A_ID$proband <- ifelse(A_ID$onsetYr %in% ascertain_span[1]:ascertain_span[2], 1, 0)

  if (sum(A_ID$proband) == 1) {
    #In this scenario we have only 1 candidate proband
    #NOTE: sim_RVped has already checked to make sure
    #that there was another affected prior to this one

    ped$proband[which(ped$ID == A_ID$ID[which(A_ID$proband == 1)])] <- 1

  } else if (sum(abs(A_ID$proband - 1)) > (num_affected - 1)) {

    #multiple available probands and the n-1 affected condition has already
    #been met by start of ascertainment period, so simply choose randomly
    #amongst available probands
    probandID <- sample(size = 1,
                        x = A_ID$ID[which(A_ID$proband == 1)])
    ped$proband[which(ped$ID == probandID)] <- 1

  } else {

    #no affecteds before ascertainment period, must choose from among
    #the nth or greater to experience onset
    A_ID$proband[1:(num_affected - 1)] <- 0
    #must write additional if statement here because of R's interesting
    #take on how sample should work when there is only one 1 to sample from....
    if (sum(A_ID$proband) == 1) {
      ped$proband[which(ped$ID == A_ID$ID[which(A_ID$proband == 1)])] <- 1
    } else {
      probandID <- sample(size = 1,
                          x = A_ID$ID[which(A_ID$proband == 1)])
      ped$proband[which(ped$ID == probandID)] <- 1
    }
  }

  return(ped)
}

#' Simulate a pedigree ascertained to contain multiple disease-affected relatives
#'
#' \code{sim_RVped} simulates a pedigree ascertained to contain multiple affected members, selects a proband, and trims the pedigree to contain only those individuals that are recalled by the proband.
#'
#' By assumption, all simulated pedigrees are segregating a genetic susceptibility variant.  We assume that the variant is rare enough that it has been introduced by one founder.  We begin the simulation of the pedigree with this founder, and transmit the rare variant from parent to offspring according to Mendel's laws.
#'
#' We begin simulating the pedigree by generating the year of birth, uniformly, between the years specified in \code{founder_byears} for the founder who introduced the rare variant to the pedigree.  Next, we simulate this founder's life events using the \code{\link{sim_lifeEvents}} function, and censor any events that occur after the study \code{stop_year}.  Possible life events include: reproduction, disease onset, and death. We continue simulating life events for any offspring, censoring events which occur after the study stop year, until the simulation process terminates.
#'
#' We do not model disease remission. Rather, we impose the restriction that individuals may only experience disease onset once, and remain affected from that point on.  If disease onset occurs then we apply the hazard rate for death in the affected population.
#'
#' \code{sim_RVped} will only return ascertained pedigrees with at least \code{num_affected} affected individuals.  That is, if a simulated pedigree does not contain at least \code{num_affected} affected individuals \code{sim_RVped} will discard the pedigree and simulate another until the condition is met.  We note that even for \code{num_affected} \eqn{= 2}, \code{sim_RVped} can be computationally expensive.  To simulate a pedigree with no proband, and without a minimum number of affected members use instead \code{\link{sim_ped}}.
#'
#' Upon simulating a pedigree with \code{num_affected} individuals, \code{sim_RVped} chooses a proband from the set of available candidates.  Candidates for proband selection must have the following qualities:
#' \enumerate{
#'   \item experienced disease onset between the years specified by \code{ascertain_span},
#'   \item if less than \code{num_affected} - 1 individuals experienced disease onset prior to the lower bound of \code{ascertain_span}, a proband is chosen from the affected individuals, such that there were at least \code{num_affected} affected individuals when the pedigree was ascertained through the proband.
#' }
#'
#' After the proband is selected, the pedigree is trimmed based on the proband's recall probability of his or her relatives.  This option is included to allow researchers to model the possibility that a proband either cannot provide a complete family history or that they explicitly request that certain family members not be contacted.  If \code{recall_probs} is missing, the default values of four times the kinship coefficient, as defined by Thompson (see references), between the proband and his or her relatives are assumed.  This has the effect of retaining all first degree relatives with probability 1, retaining all second degree relatives with probability 0.5, retaining all third degree relatives with probability 0.25, etc.  Alternatively, the user may specify a list of length \eqn{l}, such that the first \eqn{l-1} items represent the respective recall probabilities for relatives of degree \eqn{1, 2, ... , l-1} and the \eqn{l^{th}} item represents the recall probability of a relative of degree \eqn{l} or greater. For example, if \code{recall_probs = c(1, 0.75, 0.5)}, then all first degree relatives (i.e. parents, siblings, and offspring) are retained with probability 1, all second degree relatives (i.e. grandparents, grandchildren, aunts, uncles, nieces and nephews) are retained with probability 0.75, and all other relatives are retained with probability 0.5. To simulate fully ascertained pedigrees, simply specify \code{recall_probs = c(1)}.
#'
#' In the event that a trimmed pedigree fails the \code{num_affected} condition,  \code{sim_RVped} will discard that pedigree and simulate another until the condition is met.  For this reason, the values specified for \code{recall_probs} affect computation time.
#'
#' @param hazard_rates on object of class \code{hazard}, created by \code{\link{new.hazard}}.
#' @param GRR Numeric. The relative-risk of disease for individuals who inherit the causal variant.
#' @param prob_causalRV  Numeric.  The population allele frequency of the genetic variant with relative risk \code{GRR}. See details.
#' @param founder_byears Numeric vector of length 2.  The span of years from which to simulate, uniformly, the birth year for the founder who introduced the rare variant to the pedigree.
#' @param ascertain_span Numeric vector of length 2.  The year span of the ascertainment period.  This period represents the range of years during which the proband developed disease and the family would have been ascertained for multiple affected relatives.
#' @param num_affected Numeric.  The minimum number of affected individuals in the pedigree.
#' @param FamID Numeric. The family ID to assign to the simulated pedigree.
#' @param recall_probs Numeric. The proband's recall probabilities for relatives, see details.  If missing, four times kinship coefficient between the proband and the relative is used.
#' @param stop_year Numeric. The last year of study.  If missing, the current year is used.
#' @param single_founderEntry Logical. When \code{single_founderEntry = TRUE}, only 1 founder can introduce a causal variant to the pedigee; when \code{single_founderEntry = FALSE} multiple founders may introduce the causal variant.  By default, \code{single_founderEntry = TRUE}.
#' @param birth_range Numeric vector of length 2. The minimum and maximum allowable ages, in years, between which individuals may reproduce.  By default, \code{birth_range = c(18, 45)}.
#' @param NB_params Numeric vector of length 2. The size and probability parameters of the negative binomial distribution used to model the number of children per household.  By default, \code{NB_params = c(2, 4/7)}, due to the investigation of Kojima and Kelleher (1962).
#'
#' @return  A list containing the following data frames:
#' @return \code{full_ped} The full pedigree, prior to proband selection and trimming.
#' @return \code{ascertained_ped} The ascertained pedigree, with proband selected and trimmed according to proband recall probability.
#' @export
#'
#' @references OUR MANUSCRIPT
#' @references Ken-Ichi Kojima, Therese M. Kelleher. (1962), \emph{Survival of Mutant Genes}. The American Naturalist 96, 329-346.
#' @references Thompson, E. (2000). \emph{Statistical Inference from Genetic Data on Pedigrees.} NSF-CBMS Regional Conference Series in Probability and Statistics, 6, I-169. Retrieved from http://www.jstor.org.proxy.lib.sfu.ca/stable/4153187
#'
#'
#' @section See Also:
#' \code{\link{sim_ped}}, \code{\link{trim_ped}}, \code{\link{sim_lifeEvents}}
#'
#' @examples
#' #Read in age-specific hazards
#' data(AgeSpecific_Hazards)
#'
#' my_HR <- new.hazard(partition = seq(0, 100, by = 1),
#'                     hazardDF = AgeSpecific_Hazards)
#'
#' #Simulate pedigree ascertained for multiple affected individuals
#' set.seed(13)
#' ex_RVped <- sim_RVped(hazard_rates = my_HR,
#'                       GRR = 50, prob_causalRV = 1, FamID = 1,
#'                       founder_byears = c(1900, 1910),
#'                       ascertain_span = c(1900, 2015),
#'                       num_affected = 2, stop_year = 2015,
#'                       recall_probs = c(1),
#'                       single_founderEntry = TRUE)
#'
#'
#'
#'
#' #Plot ex_RVped pedigrees using the kinship2 package
#' library(kinship2)
#'
#' #Define pedigree object for full pedigree, i.e. pedigree prior to trimming
#' FullRVped <- pedigree(id = ex_RVped[[1]]$ID,
#'                         dadid = ex_RVped[[1]]$dadID,
#'                         momid = ex_RVped[[1]]$momID,
#'                         sex = (ex_RVped[[1]]$sex + 1),
#'                         affected = cbind(Affected = ex_RVped[[1]]$affected,
#'                                          RV_status = ex_RVped[[1]]$DA1 +
#'                                                      ex_RVped[[1]]$DA2),
#'                         famid = ex_RVped[[1]]$FamID)
#'
#' #plot pedigree and legend
#' plot(FullRVped['1'])
#' pedigree.legend(FullRVped, location = "topleft",  radius = 0.25)
#'
#'
#' #Define pedigree object for trimmed pedigree, i.e, pedigree with
#' # proband selected and relatives trimmed
#' TrimRVped <- pedigree(id = ex_RVped[[2]]$ID,
#'                        dadid = ex_RVped[[2]]$dadID,
#'                        momid = ex_RVped[[2]]$momID,
#'                        sex = (ex_RVped[[2]]$sex + 1),
#'                        affected = cbind(Affected = ex_RVped[[2]]$affected,
#'                                         Proband = ex_RVped[[2]]$proband,
#'                                         RV_status = ex_RVped[[2]]$DA1 +
#'                                                     ex_RVped[[2]]$DA2),
#'                        famid = ex_RVped[[2]]$FamID)['1']
#' plot(TrimRVped)
#' pedigree.legend(TrimRVped, location = "topleft",  radius = 0.25)
#'
#'
sim_RVped = function(hazard_rates, GRR, prob_causalRV,
                     founder_byears, ascertain_span, num_affected,
                     FamID, recall_probs, stop_year, single_founderEntry = TRUE,
                     birth_range = c(18, 45), NB_params = c(2, 4/7)){

  if(!is.hazard(hazard_rates)) {
    stop("Input must be an object of class hazard")
  }

  if (length(ascertain_span) != 2 | ascertain_span[1] >= ascertain_span[2]){
    stop ('please provide appropriate ascertain_span')
  }

  if (length(birth_range) != 2 | birth_range[1] >= birth_range[2]){
    stop ('please provide an appropriate birth_range')
  }

  if (GRR <= 0) {
    stop ('GRR must be greater than 0')
  } else if (GRR < 1){
    warning('Setting GRR < 1 can significantly increase computation time')
  }

  if (prob_causalRV < 0 | prob_causalRV > 1){
    stop ('prob_causalRV must be a value between 0 and 1')
  }


  if(!missing(recall_probs)) {
    if (any(recall_probs > 1) | any(recall_probs < 0) ){
      stop ('recall probabilities must be between 0 and 1')
    }
  }

  if(missing(stop_year)){
    stop_year <- as.numeric(format(Sys.Date(),'%Y'))
  }

  #generate the family pedigree, check to see that the untrimmed pedigree has
  # the appropriate number of affected individuals, if so choose a proband
  # and send to trim_ped
  D <- 0
  while(D == 0){
    d <- 0
    while( d == 0 ){
      fam_ped <- sim_ped(hazard_rates, GRR, prob_causalRV, FamID,
                         founder_byears, stop_year,
                         single_founderEntry, birth_range, NB_params)

      # prior to sending the simulated pedigree to the trim function,
      # we check to see if it meets the required criteria for number of
      # affected.  If it does, we choose a proband from the available
      # candidates prior to sending it to the trim_ped function.
      if( nrow(fam_ped) == 1 | sum(fam_ped$affected) < num_affected |
          length(fam_ped$ID[which(fam_ped$onsetYr <= ascertain_span[2])]) < 2 |
          length(fam_ped$ID[which(fam_ped$onsetYr %in%
                                  ascertain_span[1]:ascertain_span[2])]) < 1 ){
        d <- 0
      } else {
        fam_ped <- choose_proband(ped = fam_ped, num_affected, ascertain_span)
        d <- 1
      }
    }

    # Now that we have a full pedigree that meets our conditions, we trim the
    # pedigree and check to see that the trimmed pedigree STILL meets our
    # conditions, if it does not we throw it out and start all over again.
    if (missing(recall_probs)) {
      ascertained_ped <- trim_ped(ped_file = fam_ped)
    } else {
      ascertained_ped <- trim_ped(ped_file = fam_ped, recall_probs)
    }

    Oyears <- ascertained_ped$onsetYr[which(ascertained_ped$affected == 1 &
                                          ascertained_ped$available == 1 &
                                          ascertained_ped$proband == 0)]

    #determine the number of available affected individuals
    D <- ifelse(length(which(Oyears <= ascertain_span[[2]] &
                               Oyears >= ascertain_span[[1]])) >= (num_affected - 1),
                1, 0)
  }

  #return original and trimmed pedigrees
  my.return <- list(fam_ped, ascertained_ped)
  names(my.return) <- c("full_ped", "ascertained_ped")
  return(my.return)
}
