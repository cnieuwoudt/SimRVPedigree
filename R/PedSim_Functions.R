#' Create an empty ped file.
#'
#' \code{create_pedFile} initializes an empty data frame with all of the appropriate fields to simulate a pedigree using SimRVPedigree.
#'
#' @return A empty data frame with all the necessary fields needed to generate
#' a ped file using SimRVPedigree
#' @export
#'
create_pedFile = function(){
  data.frame(FamID = numeric(),
             ID = numeric(),
             gender = numeric(),
             dad_id = numeric(),
             mom_id = numeric(),
             affected = numeric(),
             DA1 = numeric(),
             DA2 = numeric(),
             birth_year = numeric(),
             onset_year = numeric(),
             death_year = numeric(),
             RR = numeric(),
             available = numeric(),
             Gen = numeric(),
             do_sim = numeric(),
             stringsAsFactors=FALSE)
}

#' Create a new mate.
#'
#' Create a new mate in pedigree.
#'
#' @param partner_info  All ped file information for the individual requiring a
#' new mate, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param last_id numeric.  The last id used in the pedigree.
#'
#' @return new_mate_info the ped file information for the new mate
#' @return last_id the updated value of last_id after mate has been added
#'
add_mate = function(partner_info, last_id){
  new_mate_info <- data.frame(FamID = partner_info$FamID,
                             ID = last_id+1,
                             gender = abs(partner_info$gender - 1),
                             dad_id = NA,
                             mom_id = NA,
                             affected = 0,
                             DA1 = 0,
                             DA2 = 0,
                             birth_year = NA,
                             onset_year = NA,
                             death_year = NA,
                             RR = NA,
                             available = 0,
                             Gen = partner_info$Gen,
                             do_sim = 0,
                             stringsAsFactors=FALSE)

  mate_return <- list(new_mate_info, last_id+1)
  return(mate_return)
}

#' Create a new offspring.
#'
#' Create a new offspring for pedigree.
#'
#' @param dad_info All ped file information of offspring's father, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param mom_info All ped file information of offspring's mother, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param byear The birth year of offspring.
#' @inheritParams add_mate
#'
#' @return new_child_info the ped file information for the new child
#' @return last_id the updated value of last_id after offspring has been added
#'
#' @importFrom stats runif
#'
add_offspring = function(dad_info, mom_info, byear, last_id){
  new_child_info <- data.frame(FamID = dad_info$FamID,
                              ID = last_id+1,
                              gender = round(runif(1)),
                              dad_id = dad_info$ID,
                              mom_id = mom_info$ID,
                              affected = 0,
                              DA1 = sample(x = c(dad_info$DA1, dad_info$DA2), size = 1),
                              DA2 = sample(x = c(mom_info$DA1, mom_info$DA2), size = 1),
                              birth_year = byear,
                              onset_year = NA,
                              death_year = NA,
                              RR = c(dad_info$RR, mom_info$RR)[which(!is.na(c(dad_info$RR, mom_info$RR)))],
                              available = 1,
                              Gen = dad_info$Gen + 1,
                              do_sim = 1,
                              stringsAsFactors=FALSE)
  child_return <- list(new_child_info, last_id+1)
  return(child_return)
}


#' Simulate all life events for an individual and create a nuclear family when
#' appropriate.
#'
#' @param found_info All ped file information for the founder, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param stop_year The last year of study.  Note: any information simulated after stop.year is censored and will not be recorded in the ped file.
#' @inheritParams get_lifeEvents
#' @inheritParams add_offspring
#'
#' @return A ped file with all life events of founding individual updated, and
#' with additional information for mate and offspring, when offspring are generated. #'
sim_nFam = function(found_info, stop_year, last_id,
                     onset_hazard, death_hazard, part,
                     birth_range, NB_params, RR){

  nfam_ped <- found_info

  #Simulate life steps for our founder
  sim_years <- get_lifeEvents(RV_status = sum(c(found_info$DA1, found_info$DA2)),
                        onset_hazard, death_hazard, part,
                        birth_range, NB_params, RR, YOB = found_info$birth_year)

  # #convert these to years
  # sim_years <- get_eventYear(Rlife_events = sim_life, byear = found_info$birth_year)

  # set the disease status based on whether or not they experience disease
  # onset prior to stop_year
  if (is.element("Onset", names(sim_years)) == TRUE) {
    o_year <- as.numeric(sim_years[which(names(sim_years) == "Onset")])
    if (o_year <= stop_year) {
      nfam_ped$affected <- 1
      nfam_ped$onset_year <- o_year
    } else {
      nfam_ped$affected <- 0
      nfam_ped$onset_year <- NA
    }
  } else {
    nfam_ped$affected <- 0
    nfam_ped$onset_year <- NA
  }

  #set the year of death if it occurs before stop_year
  d_year <- as.numeric(sim_years[which(names(sim_years) == "Death")])
  if (d_year <= stop_year) {
    nfam_ped$death_year <- d_year
  }

  #store the birth years of each child
  birth_events <- as.numeric(sim_years[which(names(sim_years) == "Birth" &
                                              sim_years <= stop_year)])

  if (length(birth_events) > 0) {
    #add a mate
    new_mate <- add_mate(partner_info = nfam_ped[1,], last_id)
    nfam_ped <- rbind(nfam_ped, new_mate[[1]])
    last_id <- new_mate[[2]]

    #store info for mom and dad (previously nfam_ped$gender below)
    dad <- nfam_ped[which(nfam_ped[,3] == 0), ]
    mom <- nfam_ped[which(nfam_ped[,3] == 1), ]

    for (k in 1:length(birth_events)) {
      #add child
      new_child <- add_offspring(dad_info = dad, mom_info = mom,
                                 byear = birth_events[k], last_id)
      nfam_ped <- rbind(nfam_ped, new_child[[1]])
      last_id <- new_child[[2]]
    }
  }

  #swich the do_sim value to 0 for the individual whose life events we have simulated
  nfam_ped$do_sim[1] = 0

  sim_fam_return = list(nfam_ped, last_id)
  return(sim_fam_return)
}

#' Simulate a pedigree.
#'
#' \code{sim_ped} randomly generates a pedigree.
#'
#' Please note distinction between \code{sim_ped} and \code{sim_RVpedigree}.  Pedigrees simulated using \code{sim_ped} do not account for study design, i.e. no requirement for multiple affected individuals in pedigree.  To simulate a pedigree likely to be ascertained according to a particular study design please use \code{\link{sim_RVpedigree}}.
#'
#' By assumption, all ascertained pedigrees are segregating a rare variant, which is rare enough to have been introduced by exactly one founder.  \code{sim_RVpedigree} starts the pedigree simulation process by simulating the birth year,  uniformly between the years specified by \code{founder_byears}, for the founder who has introduced the rare variant into the pedigree.  Next, life events are simulated for the founder.  Possible life events include: reproduction, disease onset, and death.  Currently, \code{sim_RVpedigree} only allows disease onset to occur once, i.e. no remission after disease onset.  Compuationally, this implies that after an individual has experienced disease onset, their waiting time to death is always simulated using the age-specific mortaility rates for the \emph{affected} population (i.e. the second column specified in \code{death_hazard}).  Life events for individuals who have inherited the rare variant are simulated such that their relative risk of developing disease is \code{RR}, according to a Cox proportional hazards model. For all individuals who have not inherited the rare variant, we assign a relative risk of disease onset of 1.  Any life events that occur after \code{stop_year} are censored.
#'
#' The rare variant is transmitted to any offspring of the founder according to Mendel's laws, and the process of simulating life events is repeated for offspring, recursively, until no additional offspring are produced.
#'
#'
#' @param FamID numeric. Family identification number.
#' @param founder_byears A numeric vector of length 2, the minimum and maximum founder birth years.  See details.
#' @param stop_year The last year of study.  By default, \code{stop_year} = 2015. Note: any information simulated after stop.year is censored and will not be recorded in the ped file.
#' @param birth_range A numeric vector of length 2.  By default, \code{birth_range} = c(18, 45).  The minimum and maximum allowable birth ages in simulation.
#' @param NB_params A numeric vector of length 2. By default \code{NB_params} = c(2, 4/7). The size and probabiliy parameters of the negative binomial distribution that describes the number of children per household in the population.
#' @inheritParams get_lifeEvents
#'
#' @return The ped file for the simulated pedigree.
#' @export
#' @importFrom stats runif
#'
#' @section See Also:
#' \code{\link{sim_RVpedigree}}
#'
#' @examples
#' #Define a parition of ages over which to apply the age-specific hazards
#' part_vec <- seq(0, 100, by = 1)
#'
#' #Specify age-specific mortality rates for affected and unaffected individuals
#' unaffected_mort <- 0.00001 + pgamma(seq(0.16, 16, by = .16),
#'                                     shape = 9.5, scale = 1)/350
#' affected_mort <- c(0.55, 0.48, 0.37, 0.23, 0.15,
#'                    pgamma(seq(0.96, 16, by = .16), shape = 4, scale = 1.5))/300
#'
#' #Combine mortality rates in data frame, with
#' # unaffected mortality rates in column 1, and
#' # affected mortality rates in column 2
#'
#' Dhaz_df  <- (as.data.frame(cbind(unaffected_mort, affected_mort)))
#'
#' #Specify the population age-specific onset hazard
#' Ohaz_vec <- (dgamma(seq(0.1, 10, by = .1), shape = 8, scale = 0.75))
#'
#' #Simulate a random pedigree
#' set.seed(22)
#' ex_ped <- sim_ped(onset_hazard = Ohaz_vec,
#'                   death_hazard = Dhaz_df,
#'                   part = part_vec,
#'                   RR = 5, FamID = 1,
#'                   founder_byears = c(1900, 1910))
#'
#' #Plot pedigree usign kinship2 package
#' library(kinship2)
#'
#' #Define pedigree to use kinship2's plot function
#' RV_status <- ex_ped$DA1 + ex_ped$DA2
#' Affected  <- ex_ped$affected
#'
#' ex_pedigree <- pedigree(id = ex_ped$ID,
#'                         dadid = ex_ped$dad_id,
#'                         momid = ex_ped$mom_id,
#'                         sex = (ex_ped$gender + 1),
#'                         affected = cbind(Affected, RV_status),
#'                         famid = ex_ped$FamID)
#' ExamplePed <- ex_pedigree['1']
#' plot(ExamplePed)
#' pedigree.legend(ExamplePed, location = "topleft",  radius = 0.25)


sim_ped = function(onset_hazard, death_hazard, part,
                   RR, FamID, founder_byears,
                   birth_range = c(18, 45),
                   NB_params = c(2, 4/7),
                   stop_year = 2015){

  #initialize a data frame to store all the necessary info for the ped file
  fam_ped <- create_pedFile()

  #randomly generate birth year and gender for the founder carrying the RV,
  #and fill in all other fields with the appropriate info
  fam_ped[1,] <- c(FamID,            #family ID
                   1,                #RV status
                   round(runif(1)),  #gender
                   NA, NA,           #dad_id and #mom_id
                   NA,               #affected status
                   1, 0,             #alleles 1 and 2,
                   round(runif(1, min = founder_byears[1],
                               max = founder_byears[2])), #birth year
                   NA, NA,           #onset and death years
                   RR,               #RR of developing disease
                   1, 1,             #availablilty and generation no
                   1)                # do_sim

  last_id <- 1
  last.gen <- 1

  #store the ID of individuals for whom we need to simulate life events
  re.sim <- fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last.gen)]
  while (length(re.sim) > 0) {
    for (k in 1:length(re.sim)) {
      new.kin <- sim_nFam(found_info = fam_ped[which(fam_ped$ID == re.sim[k]),],
                           stop_year, last_id,
                           onset_hazard, death_hazard, part,
                           birth_range, NB_params, RR)

      #replace individual by their simulated self and add family members when necessary
      fam_ped <- rbind(fam_ped[-which(fam_ped$ID==re.sim[k]), ],
                       new.kin[[1]])

      last_id <- new.kin[[2]]
    }
    last.gen <- max(fam_ped$Gen)
    re.sim <- fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last.gen)]
  }

  return(fam_ped[, c(1:14)])
}


#' Simulate a pedigree ascertained for multiple affected individuals.
#'
#' \code{sim_RVpedigree} simulates a pedigree with at least \code{num_affected} affecteds, according to a specified study design, selects a proband, and trims the pedigree based on the proband's recall probability of their relatives.
#'
#' By assumption, all ascertained pedigrees are segregating a rare variant, which is rare enough to have been introduced by exactly one founder.  \code{sim_RVpedigree} starts the pedigree simulation process by simulating the birth year,  uniformly between the years specified by \code{founder_byears}, for the founder who has introduced the rare variant into the pedigree.  Next, life events are simulated for the founder.  Possible life events include: reproduction, disease onset, and death.  Currently, \code{sim_RVpedigree} only allows disease onset to occur once, i.e. no remission after disease onset.  Compuationally, this implies that after an individual has experienced disease onset, their waiting time to death is always simulated using the age-specific mortaility rates for the \emph{affected} population (i.e. the second column specified in \code{death_hazard}).  Life events for individuals who have inherited the rare variant are simulated such that their relative risk of developing disease is \code{RR}, according to a Cox proportional hazards model. For all individuals who have not inherited the rare variant, we assign a relative risk of disease onset of 1.  Any life events that occur after \code{stop_year} are censored.
#'
#' The rare variant is transmitted to any offspring of the founder according to Mendel's laws, and the process of simulating life events is repeated for offspring, recursively, until no additional offspring are produced.
#'
#' Upon simulating a pedigree with \code{num_affected} individuals, \code{sim_RVpedigree} chooses a proband from the set of available candidates.  Candidates for proband selection must have the following qualities:
#' \enumerate{
#'   \item experienced disease onset between the years specified by \code{ascertain_span}
#'   \item If less than \code{num_affected} - 1 individuals have experienced onset prior to the lower bound of \code{ascertain_span}, a proband is chosen from the affected individuals, such that there were at least \code{num_affected} - 1 affected individuals when the pedigree was ascertained for the proband.
#' }
#'
#' After proband selection, the pedigree is trimmed based on the proband's recall probability of his or her relatives.  By default \code{recall_probs} is 4 times the kinship coefficent between the proband and the probands relative, which results in a recall probability of \eqn{2^{-(m-1)}} for a relative of degree \eqn{m}. Alternatively, the user may specify a list of recall probabilites of length \eqn{l > 0}, in which case the first \emph{l-1} items in \code{recall_probs} are the respective proband recall probabilites for relatives of degree \emph{1, 2, ..., l-1}, and the \emph{l}th item in \code{recall_probs} is the proband's recall probability for all relatives of degree \strong{\emph{l} or greater}.  For example, if \code{recall_probs = c(1)} all relatives will be recalled by the proband with probability 1.
#'
#' \code{sim_RVpedigree} will only return ascertained pedigrees with at least \code{num_affected} affected individuals, that is if a simulated pedigree does not contain at least \code{num_affected} affected individuals \code{sim_RVpedigree} discards that pedigree and simulates another until the condition is met.  We note that even for \code{num_affected} \eqn{= 2}, \code{sim_RVpedigree} can be computationally expensive.  To randomly simulate a pedigree without a desired number of affecteds use instead \code{\link{sim_ped}}.
#'
#' We note that, for rare diseases, this simulation process is computaionally expensive.  \strong{We highly recommend the use of parallel processing or cluster computing} when simulating a sample of \eqn{n} pedigrees ascertained for multiple affected individuals.  See parallel processing example.
#'
#'
#' @inheritParams sim_ped
#' @inheritParams trim_pedigree
#'
#' @return full_ped The full ped file, prior to proband selection and trimming.
#' @return trim_ped The trimmed ped file, trimmed according to proband recall probability.
#' @export
#'
#' @section See Also:
#' \code{\link{sim_ped}}
#'
#' @examples
#' #Read in age-specific hazards
#' data(age_specific_hazards)
#'
#' par(mfrow = c(1, 2))
#' plot(x = age_specific_hazards[,4],
#'      y = age_specific_hazards[,1],
#'      xlab = "age",
#'      ylab = "population age-specific onset hazard",
#'      col = "red3", lwd = 2, type = "s")
#' plot(x = age_specific_hazards[,4],
#'      y = age_specific_hazards[,2],
#'      xlab = "age",
#'      ylab = "age-specific death hazard",
#'      col = "dodgerblue", lwd = 2, type = "s")
#' lines(x = age_specific_hazards[,4],
#'      y = age_specific_hazards[,3],
#'      col = "goldenrod2", lwd = 2, type = "s")
#' legend("topleft", legend = c("unaffected", "affected"),
#'        col = c("dodgerblue", "goldenrod2"), lwd = 2)
#' par(mfrow = c(1, 1))
#'
#' #Simulate pedigree ascertained for multiple affected individuals
#' set.seed(22)
#' ex_RVped <- sim_RVpedigree(onset_hazard = age_specific_hazards[,1],
#'                            death_hazard = age_specific_hazards[,c(2,3)],
#'                            part = c(0, age_specific_hazards[,4]),
#'                            RR = 15, FamID = 1,
#'                            founder_byears = c(1900, 1910),
#'                            ascertain_span = c(1900, 2015),
#'                            num_affected = 2,
#'                            recall_probs = c(1, 0.75, 0.5))
#'
#'
#'
#'
#' #Plot ex_RVped pedigrees using the kinship2 package
#' library(kinship2)
#'
#' #Define pedigree object for full pedigree, i.e. pedigree prior to trimming
#' FullRVped <- pedigree(id = ex_RVped[[1]]$ID,
#'                         dadid = ex_RVped[[1]]$dad_id,
#'                         momid = ex_RVped[[1]]$mom_id,
#'                         sex = (ex_RVped[[1]]$gender + 1),
#'                         affected = cbind(Affected = ex_RVped[[1]]$affected,
#'                                          RV_status = ex_RVped[[1]]$DA1 +
#'                                                      ex_RVped[[1]]$DA2),
#'                         famid = ex_RVped[[1]]$FamID)
#'
#' #plot pedigree and legend
#' plot(FullRVped['1'])
#' pedigree.legend(FullRVped, location = "topleft",  radius = 0.25)
#'
#'
#' #Define pedigree object for trimmed pedigree, i.e, predigree with
#' # proband selected and relatives trimmed
#' TrimRVped <- pedigree(id = ex_RVped[[2]]$ID,
#'                        dadid = ex_RVped[[2]]$dad_id,
#'                        momid = ex_RVped[[2]]$mom_id,
#'                        sex = (ex_RVped[[2]]$gender + 1),
#'                        affected = cbind(Affected = ex_RVped[[2]]$affected,
#'                                         Proband = ex_RVped[[2]]$is_proband,
#'                                         RV_status = ex_RVped[[2]]$DA1 +
#'                                                     ex_RVped[[2]]$DA2),
#'                        famid = ex_RVped[[2]]$FamID)['1']
#' plot(TrimRVped)
#' pedigree.legend(TrimRVped, location = "topleft",  radius = 0.25)
#'
#'
#'
#' #how to incorporate parallel processing
#' library(doParallel)
#' library(doRNG)
#'
#' cl <- makeCluster(2)     # create cluster
#' registerDoParallel(cl)   # register cluster
#' on.exit(stopCluster(cl))
#'
#' npeds = 8    #set the number of pedigrees to generate
#' rnseed = 22  #choose a seed
#'
#' RV_peds = foreach(i = seq(npeds), .combine = rbind,
#'                   .packages = c("kinship2", "SimRVPedigree"),
#'                   .options.RNG = rnseed
#'                   ) %dorng% {
#'                   sim_RVpedigree(onset_hazard = Ohaz_vec,
#'                                  death_hazard = Dhaz_df,
#'                                  part = part_vec, RR = 5, FamID = i,
#'                                  founder_byears = c(1900, 1910),
#'                                  ascertain_span = c(1900, 2015),
#'                                  num_affected = 2)[[2]]}
#'
#' stopCluster(cl)
#'
#'
sim_RVpedigree = function(onset_hazard, death_hazard, part, RR,
                          founder_byears, ascertain_span,
                          num_affected, FamID,
                          recall_probs, birth_range = c(18, 45),
                          NB_params = c(2, 4/7), stop_year = 2015){

  check_hazpart(onset_hazard, part)
  check_part(part)
  check_dhaz(death_hazard)
  check_hazpart(death_hazard[,1], part)
  check_hazpart(death_hazard[,2], part)
  check_spans(founder_byears)
  check_spans(ascertain_span)
  check_spans(birth_range)

  if(!missing(recall_probs)) check_rprobs(recall_probs)


  #generate the family pedigree, check to see that the untrimmed pedigree has
  # the appropriate number of affected individuals
  D <- 0
  while(D == 0){
    d <- 0
    while( d == 0 ){
      fam_ped <- sim_ped(onset_hazard, death_hazard, part, RR, FamID,
                         founder_byears, birth_range, NB_params, stop_year)

      # prior to sending the simulated pedigree to the trim function,
      # we check to see if it meets the required criteria for number of
      # affected.  We also check to see that at least 1 of the affected
      # experienced onset during the ascertainment period.  If these conditions
      # are not met we discard the pedigree and simulate another until
      # these conditions are met.
      if( nrow(fam_ped) == 1 | sum(fam_ped$affected) < num_affected |
          length(fam_ped$ID[which(fam_ped$onset_year %in%
                                  ascertain_span[1]:ascertain_span[2])]) < num_affected ){
        d <- 0
      } else { d <- 1 }
    }

    # Now that we have a full pedigree that meets our conditions, we trim the
    # pedigree and check to see that the trimmed pedigree STILL meets our
    # conditions, if it does not we throw it out and start all over again.
    if (missing(recall_probs)) {
      trim_ped <- trim_pedigree(ped_file = fam_ped, ascertain_span, num_affected)
    } else {
      trim_ped <- trim_pedigree(ped_file = fam_ped, ascertain_span,
                                num_affected, recall_probs)
    }

    #determine the number of available affected individuals
    D <- ifelse(length(trim_ped$ID[which(trim_ped$available == 1 &
                                           trim_ped$affected == 1)]) < num_affected, 0, 1)
  }

  #return original and trimmed pedigrees
  my.return <- list(fam_ped, trim_ped)
  names(my.return) <- c("full_ped", "trim_ped")
  return(my.return)
}
