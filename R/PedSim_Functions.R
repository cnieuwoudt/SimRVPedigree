#' Create an Empty Pedigree
#'
#' \code{create_pedFile} initializes an empty data frame with all of the fields required by \code{sim_ped} to simulate a pedigree.
#'
#' @return An empty data frame with all fields required by \code{sim_ped} to generate a pedigree.
#' @keywords internal
#'
create_pedFile = function(){
  data.frame(FamID = numeric(),
             ID = numeric(),
             gender = numeric(),
             dad_id = numeric(),
             mom_id = numeric(),
             affected = numeric(),
             DA1 = numeric(),
             DA2 = numeric(),
             birth_year = numeric(),
             onset_year = numeric(),
             death_year = numeric(),
             RR = numeric(),
             available = numeric(),
             Gen = numeric(),
             do_sim = numeric(),
             stringsAsFactors=FALSE)
}

#' Create a New Mate
#'
#' Create new mating partner in pedigree.
#'
#' @param partner_info  Data.frame with 1 row. All pedigree information for the individual requiring a new mate, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param last_id Numeric.  The last id used in the pedigree.
#'
#' @return new_mate_info the pedigree information for the new mate.
#' @return last_id the updated value of last_id after adding the new mate.
#' @keywords internal
#'
create_mate = function(partner_info, last_id){
  new_mate_info <- data.frame(FamID = partner_info$FamID,
                             ID = last_id+1,
                             gender = abs(partner_info$gender - 1),
                             dad_id = NA,
                             mom_id = NA,
                             affected = 0,
                             DA1 = 0,
                             DA2 = 0,
                             birth_year = NA,
                             onset_year = NA,
                             death_year = NA,
                             RR = 1,
                             available = 0,
                             Gen = partner_info$Gen,
                             do_sim = 0,
                             stringsAsFactors=FALSE)

  mate_return <- list(new_mate_info, last_id+1)
  return(mate_return)
}

#' Create a New Offspring
#'
#' Create new offspring in pedigree.
#'
#' @inheritParams create_mate
#' @inheritParams sim_RVped
#' @param dad_info Data.frame with 1 row. All pedigree information of offspring's father, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param mom_info Data.frame with 1 row. All pedigree information of offspring's mother, must contain all fields generated by \code{\link{create_pedFile}}.
#' @param byear The birth year of offspring.
#'
#' @return new_child_info the pedigree information for the new child
#' @return last_id the updated value of last_id after adding new offspring
#'
#' @keywords internal
#'
#' @importFrom stats runif
#'
create_offspring = function(dad_info, mom_info, byear, last_id, RR){
  new_child_info <- data.frame(FamID = dad_info$FamID,
                              ID = last_id+1,
                              gender = round(runif(1)),
                              dad_id = dad_info$ID,
                              mom_id = mom_info$ID,
                              affected = 0,
                              DA1 = sample(x = c(dad_info$DA1, dad_info$DA2), size = 1),
                              DA2 = sample(x = c(mom_info$DA1, mom_info$DA2), size = 1),
                              birth_year = byear,
                              onset_year = NA,
                              death_year = NA,
                              RR = NA,
                              available = 1,
                              Gen = dad_info$Gen + 1,
                              do_sim = 1,
                              stringsAsFactors=FALSE)
  new_child_info$RR <- ifelse(sum(new_child_info$DA1, new_child_info$DA2) == 0, 1, RR)
  child_return <- list(new_child_info, last_id+1)
  return(child_return)
}


#' Simulate a Nuclear Family from a Single Founder
#'
#' Simulate all life events for an individual and create a nuclear family, when appropriate.
#'
#' @param found_info Data.frame with 1 row. All pedigree information for the founder, must contain all fields generated by \code{\link{create_pedFile}}.
#' @inheritParams create_mate
#' @inheritParams sim_RVped
#'
#' @keywords internal
#' @return A pedigree with updated life events for the founder, and
#' additional information for mate and offspring, when offspring are generated.
#'
sim_nFam = function(found_info, stop_year, last_id,
                    onset_hazard, death_hazard, part,
                    birth_range, NB_params, RR){

  nfam_ped <- found_info

  #Simulate life steps for our founder
  sim_years <- sim_lifeEvents(onset_hazard, death_hazard, part,
                              birth_range, NB_params,
                              RR = found_info$RR,
                              YOB = found_info$birth_year)


  # update disease status and onset year contingent on whether
  # or not they experience disease onset prior to stop_year
  if (is.element("Onset", names(sim_years)) == TRUE) {
    o_year <- as.numeric(sim_years[which(names(sim_years) == "Onset")])
    if (o_year <= stop_year) {
      nfam_ped$affected <- 1
      nfam_ped$onset_year <- o_year
    } else {
      nfam_ped$affected <- 0
      nfam_ped$onset_year <- NA
    }
  } else {
    nfam_ped$affected <- 0
    nfam_ped$onset_year <- NA
  }

  #set the year of death if it occurs before stop_year
  d_year <- as.numeric(sim_years[which(names(sim_years) == "Death")])
  if (d_year <= stop_year) {
    nfam_ped$death_year <- d_year
  }

  #store the birth years of each child
  birth_events <- as.numeric(sim_years[which(names(sim_years) == "Child" &
                                              sim_years <= stop_year)])

  if (length(birth_events) > 0) {
    #add a mate
    new_mate <- create_mate(partner_info = nfam_ped[1,], last_id)
    nfam_ped <- rbind(nfam_ped, new_mate[[1]])
    last_id <- new_mate[[2]]

    #store info for mom and dad
    dad <- nfam_ped[which(nfam_ped$gender == 0), ]
    mom <- nfam_ped[which(nfam_ped$gender == 1), ]

    for (k in 1:length(birth_events)) {
      #add child
      new_child <- create_offspring(dad_info = dad, mom_info = mom,
                                    byear = birth_events[k], last_id, RR)
      nfam_ped <- rbind(nfam_ped, new_child[[1]])
      last_id <- new_child[[2]]
    }
  }

  #set do_sim to 0 for individual whose life events we just simulated
  nfam_ped$do_sim[1] = 0

  sim_fam_return = list(nfam_ped, last_id)
  return(sim_fam_return)
}

#' Simulate a Pedigree
#'
#' Please note the distinction between \code{sim_ped} and \code{sim_RVped}.  Pedigrees simulated using \code{sim_ped} do not account for study design.  To simulate a pedigree ascertained to contain multiple family members affected by a disease please use \code{\link{sim_RVped}}.
#'
#'
#' By assumption, all pedigrees are segregating a rare variant, which is rare enough to have been introduced by exactly one founder.  \code{sim_ped} starts simulating the pedigree by generating the birth year for this founder, uniformly between the years specified by \code{founder_byears}.  Next, all life events are simulated for the founder via \code{\link{sim_lifeEvents}}.  Possible life events include: reproduction, disease onset, and death.  We only allow disease onset to occur once, i.e. no remission.  Computationally, this implies that after an individual has experienced disease onset, their waiting time to death is always simulated using the age-specific mortality rates for the \emph{affected} population (i.e. the second column specified in \code{death_hazard}).  Life events for individuals who have inherited the rare variant are simulated such that their relative risk of developing disease is \code{RR}, according to a proportional hazards model. For all individuals who have not inherited the rare variant the relative risk of disease onset is 1.  Any life events that occur after \code{stop_year} are censored.
#'
#' The rare variant is transmitted to any offspring of the founder according to Mendel's laws, and the process of simulating life events is repeated for offspring, recursively, until no additional offspring are produced.
#'
#'
#' @inheritParams sim_RVped
#'
#' @return The simulated pedigree.
#' @export
#' @importFrom stats runif
#'
#' @references OUR MANUSCRIPT
#' @references Ken-Ichi Kojima, Therese M. Kelleher. (1962), \emph{Survival of Mutant Genes}. The American Naturalist 96, 329-346.
#'
#' @section See Also:
#' \code{\link{sim_RVped}}
#'
#' @examples
#' data(AgeSpecific_Hazards)
#'
#' my_part <- seq(0, 100, by = 1)
#' my_onset_haz <- AgeSpecific_Hazards[,1]
#' my_death_haz <- AgeSpecific_Hazards[,c(2,3)]
#'
#' #Simulate a random pedigree
#' set.seed(22)
#' ex_ped <- sim_ped(onset_hazard = my_onset_haz,
#'                   death_hazard = my_death_haz,
#'                   part = my_part,
#'                   RR = 5, FamID = 1,
#'                   founder_byears = c(1900, 1910),
#'                   stop_year = 2015)
#'
#' #Plot pedigree with the kinship2 package
#' library(kinship2)
#'
#' #Define pedigree and pass to plot function
#' RV_status <- ex_ped$DA1 + ex_ped$DA2
#' Affected  <- ex_ped$affected
#'
#' ex_pedigree <- pedigree(id = ex_ped$ID,
#'                         dadid = ex_ped$dad_id,
#'                         momid = ex_ped$mom_id,
#'                         sex = (ex_ped$gender + 1),
#'                         affected = cbind(Affected, RV_status))
#' plot(ex_pedigree)
#' pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
#'
sim_ped = function(onset_hazard, death_hazard, part,
                   RR, FamID, founder_byears, stop_year,
                   birth_range = c(18, 45),
                   NB_params = c(2, 4/7)){

  #initialize a data frame to store all the necessary info for the ped file
  fam_ped <- create_pedFile()

  #randomly generate birth year and gender for the founder carrying the RV,
  #and fill in all other fields with the appropriate info
  fam_ped[1,] <- c(FamID,            #family ID
                   1,                #RV status
                   round(runif(1)),  #gender
                   NA, NA,           #dad_id and #mom_id
                   NA,               #affected status
                   1, 0,             #alleles 1 and 2,
                   round(runif(1, min = founder_byears[1],
                               max = founder_byears[2])), #birth year
                   NA, NA,           #onset and death years
                   RR,               #RR of developing disease
                   1, 1,             #availablilty and generation no
                   1)                # do_sim

  last_id <- 1
  last.gen <- 1

  #store the ID of individuals for whom we need to simulate life events
  re.sim <- fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last.gen)]
  while (length(re.sim) > 0) {
    for (k in 1:length(re.sim)) {
      new.kin <- sim_nFam(found_info = fam_ped[which(fam_ped$ID == re.sim[k]),],
                          stop_year, last_id,
                          onset_hazard, death_hazard, part,
                          birth_range, NB_params, RR)

      #replace individual by their simulated self and add family members when necessary
      fam_ped <- rbind(fam_ped[-which(fam_ped$ID==re.sim[k]), ],
                       new.kin[[1]])

      last_id <- new.kin[[2]]
    }
    last.gen <- max(fam_ped$Gen)
    re.sim <- fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last.gen)]
  }

  return(fam_ped[, c(1:14)])
}

#' Choose proband from simulated pedigree
#'
#' @param ped Pedigree simulated by \code{sim_ped}
#' @inheritParams sim_RVped
#'
#' @return Pedigree with proband selected.
#' @keywords internal
#'
choose_proband = function(ped, num_affected, ascertain_span){
  #initialize proband ID variable
  ped$proband <- 0

  #Gather info on affecteds
  A_ID <- ped[which(ped$affected == 1),
              which(colnames(ped) %in% c("onset_year", "ID", "proband"))]
  A_ID <- A_ID[order(A_ID$onset_year), ]
  A_ID$proband <- ifelse(A_ID$onset_year %in% ascertain_span[1]:ascertain_span[2], 1, 0)

  if (sum(A_ID$proband) == 1) {

    #only 1 candidate proband
    ped$proband[which(ped$ID == A_ID$ID[which(A_ID$proband == 1)])] <- 1

  } else if (sum(abs(A_ID$proband - 1)) > (num_affected - 1)) {

    #multiple available probands and the n-1 affected condition has already
    #been met by start of ascertainment period, so simply choose randomly
    #amongst available probands
    probandID <- sample(size = 1,
                        x = A_ID$ID[which(A_ID$proband == 1)])
    ped$proband[which(ped$ID == probandID)] <- 1

  } else {

    #no affecteds before ascertainment period, must choose from among
    #the nth or greater to experience onset
    A_ID$proband[1:(num_affected - 1)] <- 0
    #must write additional if statement here because of R's interesting
    #take on how sample should work when there is only one 1 to sample from....
    if (sum(A_ID$proband) == 1) {
      ped$proband[which(ped$ID == A_ID$ID[which(A_ID$proband == 1)])] <- 1
    } else {
      probandID <- sample(size = 1,
                          x = A_ID$ID[which(A_ID$proband == 1)])
      ped$proband[which(ped$ID == probandID)] <- 1
    }
  }

  return(ped)
}

#' Simulate a Pedigree Ascertained to Contain Multiple Family Members Affected by a Disease
#'
#' \code{sim_RVped} simulates a pedigree ascertained to contain multiple affected members, selects a proband, and trims the pedigree to contain only those individuals that are recalled by the proband.
#'
#' By assumption, all simulated pedigrees are segregating a genetic susceptibility variant.  We assume that the variant is rare enough that it has been introduced by one founder.  We begin the simulation of the pedigree with this founder, and transmit the rare variant from parent to offspring according to Mendel's laws.
#'
#' \code{sim_RVped} begins pedigree simulation by generating the year of birth, uniformly, between the years specified in \code{founder_byears} for the founder who introduced the rare variant to the pedigree.  Next, we simulate this founder's life events using the internal \code{\link{sim_lifeEvents}} function, and censor any events that occur after the study \code{stop_year}.  Possible life events include: reproduction, disease onset, and death. We continue simulating life events for any offspring, censoring events which occur after the study stop year, until the simulation process terminates.
#'
#' We do not model disease remission. Rather, we impose the restriction that individuals may only experience disease onset once, and remain affected from that point on.  After disease onset occurs the affected hazard rate for death is applied.
#'
#' \code{sim_RVped} will only return ascertained pedigrees with at least \code{num_affected} affected individuals.  That is, if a simulated pedigree does not contain at least \code{num_affected} affected individuals \code{sim_RVped} will discard that pedigree and simulate another until the condition is met.  We note that even for \code{num_affected} \eqn{= 2}, \code{sim_RVped} can be computationally expensive.  To simulate a pedigree with no proband, and without a minimum number of affected members use instead \code{\link{sim_ped}}.
#'
#' Upon simulating a pedigree with \code{num_affected} individuals, \code{sim_RVped} chooses a proband from the set of available candidates.  Candidates for proband selection must have the following qualities:
#' \enumerate{
#'   \item experienced disease onset between the years specified by \code{ascertain_span},
#'   \item if less than \code{num_affected} - 1 individuals experienced disease onset prior to the lower bound of \code{ascertain_span}, a proband is chosen from the affected individuals, such that there were at least \code{num_affected} - 1 affected individuals when the pedigree was ascertained for the proband.
#' }
#'
#' After the proband is selected, the pedigree is trimmed based on the proband's recall probability of his or her relatives.  This option is included to allow researchers to model the possibility that a proband either cannot provide a complete family history or that they explicitly request that certain family members not be contacted.  If \code{recall_probs} is missing, the default values of four times the kinship coefficient, as defined by Thompson (see references), between the proband and his or her relatives are assumed, which has the effect of retaining all first degree relatives with probability 1, retaining all second degree relatives with probability 0.5, retaining all third degree relatives with probability 0.25, etc [add kinship citation].  Alternatively, the user may specify a list of length $l$, such that the first $l-1$ items represent the respective recall probabilities for relatives of degree $1, 2, ... , l-1$ and the $l^{th}$ item represents the recall probability of a relative of degree $l$ or greater. For example, if \code{recall_probs = c(1, 0.75, 0.5)}, then all first degree relatives (i.e. parents, siblings, and offspring) are retained with probability 1, all second degree relatives (i.e. grandparents, grandchildren, aunts, uncles, nieces and nephews) are retained with probability 0.75, and all other relatives are retained with probability 0.5. To simulate fully ascertained pedigrees, simply specify \code{recall_probs = c(1)}.
#'
#' @param onset_hazard Numeric. The population age-specific hazard rate for disease.
#' @param death_hazard Data.frame. Column 1 should specify the age-specific hazard rate for death in the unaffected population, and column 2 should specify the age-specific hazard rate for death in the affected population. See details.
#' @param part Numeric. The partition of ages over which to apply the age-specific hazard rates in \code{onset_hazard} and \code{death_hazard}.
#' @param RR Numeric. The relative risk of disease for individuals who inherit the rare variant.
#' @param founder_byears Numeric list of length 2.  The span of years from which to simulate, uniformly, the birth year for the founder who introduced the rare variant to the pedigree.
#' @param ascertain_span Numeric list of length 2.  The year span of the ascertainment period.  This period represents the range of years during which the proband developed disease and the family would have been ascertained for multiple affected relatives.
#' @param num_affected Numeric.  The minimum number of affected individuals in the pedigree.
#' @param FamID Numeric. The family ID to assign to the simulated pedigree.
#' @param recall_probs Numeric. The proband's recall probabilities for relatives, see details.  If missing, four times kinship coefficient between the proband and the relative is used.
#' @param stop_year Numeric. The last year of study.  If missing, the current year is used.
#' @param birth_range Numeric list of length 2. The minimum and maximum allowable ages, in years, between which individuals may reproduce.  By default, \code{birth_range = c(18, 45)}.
#' @param NB_params Numeric list of length 2. The size and probability parameters of the negative binomial distribution used to model the number of children per household.  By default, \code{NB_params = c(2, 4/7)}, due to the investigation of Kojima and Kelleher (1962).
#'
#' @return  A list containing the following data frames:
#' @return \code{full_ped} The full pedigree, prior to proband selection and trimming.
#' @return \code{ascertained_ped} The ascertained pedigree, with proband selected and trimmed according to proband recall probability.
#' @export
#'
#' @references OUR MANUSCRIPT
#' @references Ken-Ichi Kojima, Therese M. Kelleher. (1962), \emph{Survival of Mutant Genes}. The American Naturalist 96, 329-346.
#' @references Thompson, E. (2000). \emph{Statistical Inference from Genetic Data on Pedigrees.} NSF-CBMS Regional Conference Series in Probability and Statistics, 6, I-169.
#'
#'
#' @section See Also:
#' \code{\link{sim_ped}}, \code{\link{trim_ped}}, \code{\link{sim_lifeEvents}}
#'
#' @examples
#' #Read in age-specific hazards
#' data(AgeSpecific_Hazards)
#'
#' #Simulate pedigree ascertained for multiple affected individuals
#' set.seed(13)
#' ex_RVped <- sim_RVped(onset_hazard = AgeSpecific_Hazards[,1],
#'                       death_hazard = AgeSpecific_Hazards[,c(2,3)],
#'                       part = seq(0, 100, by = 1),
#'                       RR = 15, FamID = 1,
#'                       founder_byears = c(1900, 1910),
#'                       ascertain_span = c(1900, 2015),
#'                       num_affected = 2, stop_year = 2015,
#'                       recall_probs = c(1, 0.75, 0.5))
#'
#'
#'
#'
#' #Plot ex_RVped pedigrees using the kinship2 package
#' library(kinship2)
#'
#' #Define pedigree object for full pedigree, i.e. pedigree prior to trimming
#' FullRVped <- pedigree(id = ex_RVped[[1]]$ID,
#'                         dadid = ex_RVped[[1]]$dad_id,
#'                         momid = ex_RVped[[1]]$mom_id,
#'                         sex = (ex_RVped[[1]]$gender + 1),
#'                         affected = cbind(Affected = ex_RVped[[1]]$affected,
#'                                          RV_status = ex_RVped[[1]]$DA1 +
#'                                                      ex_RVped[[1]]$DA2),
#'                         famid = ex_RVped[[1]]$FamID)
#'
#' #plot pedigree and legend
#' plot(FullRVped['1'])
#' pedigree.legend(FullRVped, location = "topleft",  radius = 0.25)
#'
#'
#' #Define pedigree object for trimmed pedigree, i.e, pedigree with
#' # proband selected and relatives trimmed
#' TrimRVped <- pedigree(id = ex_RVped[[2]]$ID,
#'                        dadid = ex_RVped[[2]]$dad_id,
#'                        momid = ex_RVped[[2]]$mom_id,
#'                        sex = (ex_RVped[[2]]$gender + 1),
#'                        affected = cbind(Affected = ex_RVped[[2]]$affected,
#'                                         Proband = ex_RVped[[2]]$proband,
#'                                         RV_status = ex_RVped[[2]]$DA1 +
#'                                                     ex_RVped[[2]]$DA2),
#'                        famid = ex_RVped[[2]]$FamID)['1']
#' plot(TrimRVped)
#' pedigree.legend(TrimRVped, location = "topleft",  radius = 0.25)
#'
#'
sim_RVped = function(onset_hazard, death_hazard, part, RR,
                     founder_byears, ascertain_span, num_affected,
                     FamID, recall_probs, stop_year,
                     birth_range = c(18, 45), NB_params = c(2, 4/7)){

  if (any(is.na(onset_hazard)) | any(is.na(death_hazard)) | any(is.na(part))) {
    stop('age-specific hazards and age partition cannot contain missing values')
  }

  if (min(part) != 0) {
    stop('age-specific hazards must begin at birth')
  } else if (max(part) < 65){
    warning ('For optimal results please specify age-specific hazards that begin at birth and end near the life expectancy of the population to which the age-specific hazards apply.')
  }

  if (length(part) == 1 |
      length(part) != (length(onset_hazard) + 1) |
      length(part) != (nrow(death_hazard) + 1) ) {
    stop ('please provide hazards, such that length(part) == length(hazard) + 1')
  }

  if(class(death_hazard) != "data.frame"){
    stop("death_hazard must be a data frame with 2 columns:,
         column 1 = unaffected age-specific death hazard,
         column 2 = affected age-specific death hazard")
  }else if(ncol(death_hazard) != 2){
    stop("death_hazard must be a data frame with 2 columns:,
         column 1 = unaffected age-specific death hazard,
         column 2 = affected age-specific death hazard")
  }else if(sum(death_hazard[,1] > death_hazard[,2]) > nrow(death_hazard)/2){
    warning("Please check that you have specified death_hazard such that:,
            column 1 = UNAFFECTED age-specific death hazard,
            column 2 = AFFECTED age-specific death hazard")
  }


  if (length(ascertain_span) != 2 | ascertain_span[1] >= ascertain_span[2]){
    stop ('please provide appropriate ascertain_span')
  }

  if (length(birth_range) != 2 | birth_range[1] >= birth_range[2]){
    stop ('please provide appropriate birth_range')
  }

  if (RR <= 0) {
    stop ('RR must be greater than 0')
  } else if (RR < 1){
    warning('Setting RR < 1 can significantly increase computation time')
  }

  if(!missing(recall_probs)) {
    if (any(recall_probs > 1) | any(recall_probs < 0) ){
      stop ('recall probabilities must be between 0 and 1')
    }
  }

  if(missing(stop_year)){
    stop_year <- as.numeric(format(Sys.Date(),'%Y'))
  }

  #generate the family pedigree, check to see that the untrimmed pedigree has
  # the appropriate number of affected individuals, if so choose a proband
  # and send to trim_ped
  D <- 0
  while(D == 0){
    d <- 0
    while( d == 0 ){
      fam_ped <- sim_ped(onset_hazard, death_hazard, part, RR, FamID,
                         founder_byears, stop_year, birth_range, NB_params)

      # prior to sending the simulated pedigree to the trim function,
      # we check to see if it meets the required criteria for number of
      # affected.  If it does, we choose a proband from the available
      # candidates prior to sending it to the trim_ped function.
      if( nrow(fam_ped) == 1 | sum(fam_ped$affected) < num_affected |
          length(fam_ped$ID[which(fam_ped$onset_year %in%
                                  ascertain_span[1]:ascertain_span[2])]) < 1 ){
        d <- 0
      } else {
        fam_ped <- choose_proband(ped = fam_ped, num_affected, ascertain_span)
        d <- 1
      }
    }

    # Now that we have a full pedigree that meets our conditions, we trim the
    # pedigree and check to see that the trimmed pedigree STILL meets our
    # conditions, if it does not we throw it out and start all over again.
    if (missing(recall_probs)) {
      ascertained_ped <- trim_ped(ped_file = fam_ped)
    } else {
      ascertained_ped <- trim_ped(ped_file = fam_ped, recall_probs)
    }

    Oyears <- ascertained_ped$onset_year[which(ascertained_ped$affected == 1 &
                                          ascertained_ped$available == 1 &
                                          ascertained_ped$proband == 0)]

    #determine the number of available affected individuals
    D <- ifelse(length(which(Oyears <= ascertain_span[[2]] &
                               Oyears >= ascertain_span[[1]])) >= (num_affected - 1),
                1, 0)
  }

  #return original and trimmed pedigrees
  my.return <- list(fam_ped, ascertained_ped)
  names(my.return) <- c("full_ped", "ascertained_ped")
  return(my.return)
}
