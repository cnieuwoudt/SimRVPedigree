#' Create empty ped file
#'
#' \code{create_pedFile} initializes an empty data frame with all of the appropriate fields to simulate a pedigree using SimRVPedigree.
#'
#' @return A empty data frame with all the necessary fields needed to generate
#' a ped file using SimRVPedigree
#' @export
#'
create_pedFile = function(){
  data.frame(FamID = numeric(),
             ID = numeric(),
             gender = numeric(),
             dad_id = numeric(),
             mom_id = numeric(),
             affected = numeric(),
             DA1 = numeric(),
             DA2 = numeric(),
             Gen = numeric(),
             birth_year = numeric(),
             onset_year = numeric(),
             death_year = numeric(),
             RR = numeric(),
             do_sim = numeric(),
             available = numeric(),
             stringsAsFactors=FALSE)
}

#' Create a new mating partner
#'
#' @param partner_info  All ped file information for the individual requiring a
#' new mate, must contain all fields generated by \link{create_pedFile}.
#' @param last_id numeric.  The last id used in the pedigree.
#'
#' @return new_mate_info the ped file information for the new mate
#' @return last_id the updated value of last_id after mate has been added
#'
add_mate = function(partner_info, last_id){
  new_mate_info <- data.frame(FamID = partner_info$FamID,
                             ID = last_id+1,
                             gender = abs(partner_info$gender-1),
                             dad_id = NA,
                             mom_id = NA,
                             affected = 0,
                             DA1 = 0,
                             DA2 = 0,
                             Gen = partner_info$Gen,
                             birth_year = NA,
                             onset_year = NA,
                             death_year = NA,
                             RR = NA,
                             do_sim = 0,
                             available = 0,
                             stringsAsFactors=FALSE)

  mate_return <- list(new_mate_info, last_id+1)
  return(mate_return)
}

#' Create new offspring
#'
#' @param dad_info All ped file information of offspring's father, must contain all fields generated by \link{create_pedFile}.
#' @param mom_info All ped file information of offspring's mother, must contain all fields generated by \link{create_pedFile}.
#' @param byear The birth year of offspring.
#' @inheritParams add_mate
#'
#' @return new_child_info the ped file information for the new child
#' @return last_id the updated value of last_id after offspring has been added
#'
add_offspring = function(dad_info, mom_info, byear, last_id){
  new_child_info <- data.frame(FamID = dad_info$FamID,
                              ID = last_id+1,
                              gender = round(runif(1)),
                              dad_id = dad_info$ID,
                              mom_id = mom_info$ID,
                              affected = 0,
                              DA1 = sample(x = c(dad_info$DA1, dad_info$DA2), size = 1),
                              DA2 = sample(x = c(mom_info$DA1, mom_info$DA2), size = 1),
                              Gen = dad_info$Gen + 1,
                              birth_year = byear,
                              onset_year = NA,
                              death_year = NA,
                              RR = c(dad_info$RR, mom_info$RR)[which(!is.na(c(dad_info$RR, mom_info$RR)))],
                              do_sim = 1,
                              available = 1,
                              stringsAsFactors=FALSE)
  child_return <- list(new_child_info, last_id+1)
  return(child_return)
}

#' Convert event waiting times to year of event
#'
#' @param Rlife_events Named matrix of all life events returned from
#' \link{life_step}
#' @param byear The birth year
#'
#' @return Named matrix. The years when simulated life events occur,
#' named according to which life event has occurred.
#'
date_step = function(Rlife_events, byear){
  life_years <- round(cumsum(as.numeric(Rlife_events[1,]))) + byear
  names(life_years) <- names(Rlife_events)
  return(life_years)
}

#' Simulate all life events for an individual and create a nuclear family when
#' appropriate.
#'
#' @param found_info All ped file information for the founder, must contain all fields generated by \link{create_pedFile}.
#' @param stop_year The last year of study.  Note: any information simulated after stop.year is censored and will not be recorded in the ped file.
#' @inheritParams life_step
#' @inheritParams add_offspring
#'
#' @return A ped file with all life events of founding individual updated, and
#' with additional information for mate and offspring, when offspring are generated. #'
nfam_step = function(found_info, stop_year, last_id,
                     onset_hazard, death_hazard, part,
                     birth_range, NB_params, RR){

  nfam_ped = found_info

  #Simulate life steps for our founder
  sim.life = life_step(RV_status = sum(c(found_info$DA1, found_info$DA2)),
                       onset_hazard, death_hazard, part,
                       birth_range, NB_params, RR)

  #convert these to years
  sim.years = date_step(Rlife_events = sim.life, byear = found_info$birth_year)

  #set the disease status based on whether or not they experience disease onset prior to stop_year
  onset.true = is.element("Onset", names(sim.years))
  if (onset.true == TRUE) {
    o.year = as.numeric(sim.years[which(names(sim.years) == "Onset")])
    if (o.year <= stop_year) {
      nfam_ped$affected = 1
      nfam_ped$onset_year = o.year
    } else {
      nfam_ped$affected = 0
      nfam_ped$onset_year = NA
    }
  } else {
    nfam_ped$affected = 0
    nfam_ped$onset_year = NA
  }

  #set the year of death if it occurs before stop_year
  d.year = as.numeric(sim.years[which(names(sim.years) == "Death")])
  if (d.year <= stop_year) {
    nfam_ped$death_year = d.year
  }

  #store the birth years of each child
  birth.events = as.numeric(sim.years[which(names(sim.years) == "Birth" &
                                              sim.years <= stop_year)])

  if (length(birth.events) > 0) {
    #add a mate
    new.mate = add_mate(partner_info = nfam_ped[1,], last_id)
    nfam_ped = rbind(nfam_ped, new.mate[[1]])
    last_id = new.mate[[2]]

    #store info for mom and dad
    dad = nfam_ped[which(nfam_ped$gender == 0), ]
    mom = nfam_ped[which(nfam_ped$gender == 1), ]

    for (k in 1:length(birth.events)) {
      #add child
      new.child = add_offspring(dad_info = dad, mom_info = mom,
                            byear = birth.events[k], last_id)
      nfam_ped = rbind(nfam_ped, new.child[[1]])
      last_id = new.child[[2]]
    }
  }

  #swich the do_sim value to 0 for the individual whose life events we have simulated
  nfam_ped$do_sim[1] = 0

  sim.fam.return = list(nfam_ped, last_id)
  return(sim.fam.return)
}

#' Simulate a full pedigree
#'
#' \code{ped_step} randomly generates a full pedigree.
#'
#' \code{ped_step} randomly generates a pedigree starting with the founder who introduced the rare variant.  We assumed that the variant is rare enough that it has only been introduced to the pedigree by one of the two oldest founders.  The variant is transmitted to offspring according to Mendel's laws.  Life events for individuals who have inherited the rare variant (RV) are simulated such that their relative risk is \code{RR}, all others are simulated with a relative risk of 1.  All events which occur after the specified \code{stop_year} are censored.
#'
#'  The birth year for the founder with the rare variant is simulated uniformly between the years specified in \code{founder_byears}.
#'
#' @param founder_byears A numeric vector of length 2, the minimum and maximum founder birth years.  See details.
#' @param stop_year The last year of study.  By default, \code{stop_year} = 2015. Note: any information simulated after stop.year is censored and will not be recorded in the ped file.
#' @param birth_range A numeric vector of length 2.  By default, \code{birth_range} = c(18, 45).  The minimum and maximum allowable birth ages in simulation.
#' @param NB_params A numeric vector of length 2. By default \code{NB_params} = c(2, 4/7). The size and probabiliy parameters of the negative binomial distribution that describes the number of children per household in the population.
#' @inheritParams life_step
#'
#' @return The ped file for the simulated pedigree.
#' @export
#' @examples
#' part_vec <- seq(0, 100, by = 1)
#' unaffected_mort <- 0.00001 + pgamma(seq(0.16, 16, by = .16),
#'                                     shape = 9.5, scale = 1)/350
#' affected_mort <- c(0.55, 0.48, 0.37, 0.23, 0.15,
#'                    pgamma(seq(0.96, 16, by = .16), shape = 4, scale = 1.5))/300
#' Dhaz_df  <- (as.data.frame(cbind(unaffected_mort, affected_mort)))
#' Ohaz_vec <- (dgamma(seq(0.1, 10, by = .1), shape = 8, scale = 0.75))
#' set.seed(22)
#' ex_ped <- ped_step(onset_hazard = Ohaz_vec, death_hazard = Dhaz_df,
#'                    part = part_vec, RR = 5, founder_byears = c(1900, 1910))

ped_step = function(onset_hazard, death_hazard, part,
                    RR, founder_byears,
                    birth_range = c(18, 45),
                    NB_params = c(2, 4/7),
                    stop_year = 2015){

  #initialize a data frame to store all the necessary info for the ped file
  fam_ped = create_pedFile()

  #randomly generate birth year and gender for the founder carrying the RV,
  #and fill in all other fields with the appropriate info
  fam_ped[1,] = c(NA,               #family ID
                  1,                #RV status
                  round(runif(1)),  #gender
                  NA, NA,           #dad_id and #mom_id
                  NA,               #affected status
                  1, 0,             #alleles 1 and 2,
                  1,                #generation no
                  round(runif(1, min = founder_byears[1], max = founder_byears[2])), #birth year
                  NA, NA,           #onset and death years
                  RR,               #RR of developing disease
                  1, 1)             # do_sim and availablilty

  last_id = 1
  last.gen = 1

  #store the ID of individuals for whom we need to simulate life events
  re.sim = fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last.gen)]
  while (length(re.sim) > 0) {
    for (k in 1:length(re.sim)) {
      new.kin = nfam_step(found_info = fam_ped[which(fam_ped$ID == re.sim[k]),],
                          stop_year, last_id,
                          onset_hazard, death_hazard, part,
                          birth_range, NB_params, RR)

      #replace individual by their simulated self and add family members when necessary
      fam_ped = rbind(fam_ped[-which(fam_ped$ID==re.sim[k]), ],
                      new.kin[[1]])

      last_id = new.kin[[2]]
    }
    last.gen = max(fam_ped$Gen)
    re.sim = fam_ped$ID[which(fam_ped$do_sim == 1 & fam_ped$Gen == last.gen)]
  }

  return(fam_ped[, c(1:8,10:13,15,9)])
}


#' Simulate a pedigree ascertained for a given number of affected.
#'
#' \code{sim_RVpedigree} simulates a pedigree with the desired number of
#' affected, chooses a proband,and trims the pedigree based on the proband's
#' recall probability of his or her relatives
#'
#' By default \code{recall_probs} is 4 times the kinship coefficent between the
#' proband and the probands relative, which results in a recall probability of
#' \eqn{2^{-(n-1)}} for a relative of degree \eqn{n}. Alternatively, the user may
#' specify a list of recall probabilites of length \eqn{l > 0}, in which case
#' the first \emph{l-1} items in \code{recall_probs} are the respective proband
#' recall probabilites for relatives of degree \emph{1, 2, ..., l-1}, and the
#' \emph{l}th item in \code{recall_probs} is the proband's recall probability for
#' all relatives of degree \strong{\emph{l} or greater}.  For example if
#' \code{recall_probs = c(1)} all relatives will be recalled by the proband with
#' probability 1.
#'
#' This section will be details for the function... still need to add these.
#'
#'
#' @param family_num numeric. The family number to assign the simulated RV pedigree.
#' @inheritParams ped_step
#' @inheritParams trim_step
#'
#' @return full_ped The full ped file, prior to proband selection and trimming.
#' @return trim_ped The trimmed ped file, trimmed according to proband recall probability.
#' @export
#'
#' @examples
#' part_vec <- seq(0, 100, by = 1)
#' unaffected_mort <- 0.00001 + pgamma(seq(0.16, 16, by = .16),
#'                                     shape = 9.5, scale = 1)/350
#' affected_mort <- c(0.55, 0.48, 0.37, 0.23, 0.15,
#'                    pgamma(seq(0.96, 16, by = .16), shape = 4, scale = 1.5))/300
#' Dhaz_df  <- (as.data.frame(cbind(unaffected_mort, affected_mort)))
#' Ohaz_vec <- (dgamma(seq(0.1, 10, by = .1), shape = 8, scale = 0.75))
#' set.seed(22)
#' ex_RVped <- sim_RVpedigree(onset_hazard = Ohaz_vec, death_hazard = Dhaz_df,
#'                            part = part_vec, RR = 5,
#'                            founder_byears = c(1900, 1910),
#'                            ascertain_span = c(1900, 2015),
#'                            num_affected = 2, family_num = 1)
#'
#' plot_RVpedigree(ex_RVped[[1]])
#' plot_RVpedigree(ex_RVped[[2]])
#'
sim_RVpedigree = function(onset_hazard, death_hazard, part, RR,
                      founder_byears, ascertain_span,
                      num_affected, family_num,
                      recall_probs,
                      birth_range = c(18, 45),
                      NB_params = c(2, 4/7),
                      stop_year = 2015){

  #generate the family pedigree, check to see that the untrimmed pedigree has
  # the appropriate number of affected individuals
  D <- 0
  while(D <= 0){
    d <- 0
    while( d <= 0 ){
      fam_ped <- ped_step(onset_hazard, death_hazard, part, RR,
                         founder_byears, birth_range, NB_params, stop_year)
      fam_ped$FamID <- family_num

      # prior to sending the simulated pedigree to the trim function,
      # we check to see if it meets the required criteria for number of
      # affected.  We also check to see that at least 1 of the affected
      # experienced onset during the ascertainment period.  If these conditions
      # are not met we discard the pedigree and simulate another until
      # these conditions are met.
      if( nrow(fam_ped) == 1 | sum(fam_ped$affected) < num_affected |
          length(fam_ped$ID[which(fam_ped$onset_year %in%
                                  ascertain_span[1]:ascertain_span[2])]) < num_affected ){
        d <- 0
      } else { d <- 1 }
    }

    # Now that we have a full pedigree that meets our conditions, we trim the
    # pedigree and check to see that the trimmed pedigree STILL meets our
    # conditions, if it does not we throw it out and start all over again.
    if (missing(recall_probs)) {
      trim_ped <- trim_step(ped_file = fam_ped, ascertain_span)
    } else {
      trim_ped <- trim_step(ped_file = fam_ped, ascertain_span, recall_probs)
    }

    #determine the number of available affected individuals
    avail.affect <- trim_ped$ID[which(trim_ped$available == 1 & trim_ped$affected == 1)]
    D <- ifelse(length(avail.affect) < num_affected, 0, 1)
  }

  #return original and trimmed pedigrees
  my.return <- list(fam_ped, trim_ped)
  names(my.return) <- c("full_ped", "trim_ped")
  return(my.return)
}


# ##------------##
# ##  Sim_Peds  ##
# ##------------##
# ## Create a function that will simulate n pedigrees, gives user a progress bar,
# ## but no parallization here
# ##
# ## Arguments____________________________________________________________________
# ## npeds          - constant; number of pedigrees to simulate
# ## onset_hazard   - vector; age specific incidence rates for the disease of interest
# ## death_hazard   - data.frame; age specific mortality rates
# ## part           - vector; partition over which to apply onset and death rates
# ## RR           - constant; the RR for developing disease
# ## founder_byears - vector; length 2, years to be chosen from uniformly for founder birth year
# ## ascertain_span    - vector, length = 2, the acertainment period of the study
# ##                          i.e., years in which proband became affected
# ## num_affected   - constant; number of affected in simulated family
# ## recall_probs   - vector, length n, probability proband recalls relatives of degree n
# ## birth_range    - vector; max and min birth ages
# ## NB_params      - vector; size and probability parameters for NB distribution
# ## stop_year      - constant:
# ##
# ## Function Requirements________________________________________________________
# ## sim_family
# ##
# ## Package Requirements_________________________________________________________
# ## NONE
# ##
# Sim_Peds = function(npeds, RR,
#                     onset_hazard, death_hazard, part,
#                     founder_byears, ascertain_span,
#                     num_affected, recall_probs,
#                     birth_range = c(18, 45), NB_params = c(2, 4/7),
#                     stop_year = 2015){
#
#
#   ped_files = create_pedFile()
#   ped.RRs = rep(RR, npeds)
#   my.count = 1
#   pb <- txtProgressBar(min = 0, max = length(ped.RRs), style = 3)
#   for(m in 1:length(ped.RRs)){
#     loop.fam = sim_family(onset_hazard, death_hazard, part, RR = ped.RRs[m],
#                           founder_byears, ascertain_span,
#                           num_affected, family_num = my.count,
#                           recall_probs,
#                           birth_range, NB_params, stop_year)[[2]]
#     ped_files = rbind(ped_files, loop.fam)
#     setTxtProgressBar(pb, m)
#     my.count = my.count + 1
#     }
#   return(ped_files)
# }
