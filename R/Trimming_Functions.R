#' Choose proband and trim pedigree
#'
#' \code{trim_pedigree} chooses a proband from the pedigree and trims relatives
#' based on the proband's recall probability of that relative.
#'
#' By default \code{recall_probs} is 4 times the kinship coefficent between the
#' proband and the probands relative, which results in a recall probability of
#' \eqn{2^{-(n-1)}} for a relative of degree \eqn{n}. Alternatively, the user may
#' specify a list of recall probabilites of length \eqn{l > 0}, in which case
#' the first \emph{l-1} items in \code{recall_probs} are the respective proband
#' recall probabilites for relatives of degree \emph{1, 2, ..., l-1}, and the
#' \emph{l}th item in \code{recall_probs} is the proband's recall probability for
#' all relatives of degree \strong{\emph{l} or greater}.  For example if
#' \code{recall_probs = c(1)} all relatives will be recalled by the proband with
#' probability 1.
#'
#'
#' @param ped_file A data.frame. The ped file generated by \code{ped_step}.
#' @param ascertain_span numeric vector of length 2. The ascertainment period,
#' i.e. first and last year of study.
#' @param num_affected Numeric.  The desired number of affected.
#' @param recall_probs Numeric.  Proband recall probabilities.  See details.
#'
#' @return The trimmed ped file
#' @export
#'
#' @importFrom kinship2 kinship
#' @importFrom stats runif
#'
#' @examples
#' #Define a parition of ages over which to apply the age-specific hazards
#' part_vec <- seq(0, 100, by = 1)
#'
#' #Specify age-specific mortality rates for affected and unaffected individuals
#' unaffected_mort <- 0.00001 + pgamma(seq(0.16, 16, by = .16),
#'                                     shape = 9.5, scale = 1)/350
#' affected_mort <- c(0.55, 0.48, 0.37, 0.23, 0.15,
#'                    pgamma(seq(0.96, 16, by = .16), shape = 4, scale = 1.5))/300
#'
#' #Combine mortality rates in data frame, with
#' # unaffected mortality rates in column 1, and
#' # affected mortality rates in column 2
#' Dhaz_df  <- (as.data.frame(cbind(unaffected_mort, affected_mort)))
#'
#' #Specify the population age-specific onset hazard
#' Ohaz_vec <- (dgamma(seq(0.1, 10, by = .1), shape = 2, scale = 3.5))/100
#'
#' ## Simulate a random pedigree
#' set.seed(222)
#' ex_ped <- sim_RVpedigree(onset_hazard = Ohaz_vec,
#'                          death_hazard = Dhaz_df,
#'                          part = part_vec, RR = 10, FamID = 1,
#'                          founder_byears = c(1900, 1910),
#'                          ascertain_span = c(1980, 2015),
#'                          num_affected = 2)[[1]]
#'
#' #plot ex_ped using kinship2
#' library(kinship2)
#' ex_pedigree <- pedigree(id = ex_ped$ID,
#'                         dadid = ex_ped$dad_id,
#'                         momid = ex_ped$mom_id,
#'                         sex = (ex_ped$gender + 1),
#'                         affected = cbind(Affected = ex_ped$affected,
#'                                    RV_status = ex_ped$DA1 + ex_ped$DA2),
#'                         famid = ex_ped$FamID)['1']
#' plot(ex_pedigree)
#' pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
#' mtext("Original Pedigree", side = 3, line = 2)
#'
#'
#' ## Trim pedigree examples
#' #define lists of various trimming parameters to
#' #illustrate the effects of various settings
#' Recall_Probabilities <- list(r1 = c(1),  #will result in same ped as ex_ped
#'                              r2 = c(1, 0.5, 0.125),
#'                              r3 = c(1, 0.5, 0.125))
#'
#' Number_Affected <- c(2, 2, 2)
#' Ascertainment_Span <- list(span1 = c(2010, 2015),
#'                            span2 = c(2010, 2015),
#'                            span3 = c(2000, 2015))
#'
#' for (k in 1:length(Number_Affected)) {
#'    set.seed(2)
#'    #trim pedigree
#'    TrimPed <- trim_pedigree(ped_file = ex_ped,
#'                             ascertain_span = Ascertainment_Span[[k]],
#'                             num_affected = Number_Affected[[k]],
#'                             recall_probs = Recall_Probabilities[[k]])
#'
#'    #plot trimmed pedigree
#'    Tped <- pedigree(id = TrimPed$ID,
#'                     dadid = TrimPed$dad_id,
#'                     momid = TrimPed$mom_id,
#'                     sex = (TrimPed$gender + 1),
#'                     affected = cbind(Affected = TrimPed$affected,
#'                                      Proband = TrimPed$is_proband,
#'                                      RV_status = TrimPed$DA1 + TrimPed$DA2),
#'                     famid = TrimPed$FamID)['1']
#'
#'    plot(Tped)
#'    pedigree.legend(Tped, location = "topleft",  radius = 0.25)
#'    mtext(paste0("recall_probs = (", sep = "",
#'                 paste(Recall_Probabilities[[k]], collapse = ", "),
#'                 ")\n ascertain_span = (",
#'                 paste(Ascertainment_Span[[k]], collapse = ", "),
#'                 ")\n num_affected = ", Number_Affected[[k]]),
#'                 side = 3 )
#' }
#'
#'
trim_pedigree = function(ped_file, ascertain_span, num_affected, recall_probs){
  #First we must randomly choose a proband from the individuals who
  #experienced onset during ascertain_span, keeping in mind that there should
  #be num_affected - 1 individuals who have experienced onset before the proband
  #Gather info on probands in AffIDs
  AffIDs <- ped_file[which(ped_file$affected == 1),
                    which(colnames(ped_file) %in% c("onset_year", "ID"))]
  AffIDs <- AffIDs[order(AffIDs$onset_year), ]
  AffIDs$poss_proband <- ifelse(AffIDs$onset_year %in%
                                  ascertain_span[1]:ascertain_span[2], 1, 0)

  #issue error message if num_affected violated.
  if (nrow(AffIDs) < num_affected) stop ('num_affected condition not met')

  if (sum(AffIDs$poss_proband) == 1) {
    #only 1 available proband
    probandID <- AffIDs$ID[which(AffIDs$poss_proband == 1)]
  } else if (sum(abs(AffIDs$poss_proband - 1)) > (num_affected - 1)) {
    #multiple available probands and the n-1 affected condition has already
    #been met by start of ascertainment period, so simply choose randomly
    #amongst available probands
    probandID <- sample(size = 1,
                        x = AffIDs$ID[which(AffIDs$poss_proband == 1)])
  } else {
    #no affecteds before ascertainment period, must choose from among the nth
    #or greater to experience onset
    AffIDs$poss_proband[1:(num_affected - 1)] <- 0
    probandID <-  sample(size = 1,
                         x = AffIDs$ID[which(AffIDs$poss_proband == 1)])
  }

  # generate a vector of Unif(0,1) RVs, to determine who is trimmed
  u <- runif(length(ped_file$ID))

  #calculate the kinship matrix for our pedigree
  kin_mat <- kinship(ped_file,
                     id = ped_file$ID,
                     dadid = ped_file$dad_id,
                     momid = ped_file$mom_id)

  kin_proband <- kin_mat[, which(ped_file$ID == probandID)]

  #if recall_probs have not been supplied just use 4*kinship coefficent
  if (missing(recall_probs)) {
    # keep only those individuals for whom 4*kinship coefficent with the proband
    # is greater than runif(1).  This will result in keeping parents, offspring,
    # and siblings with probability 1

    ped_trim <- ped_file[4*kin_proband >= u, ]
  } else if (sum(recall_probs) == 1 & length(recall_probs) == 1) {
    ped_trim <- ped_file
  } else {
    # create rprobs, which associates the recall probabilities
    # specified by the user with the appropriate individuals in the pedigree.

    rprobs <- rep(NA, length(ped_file$ID))

    # set recall probability for proband to 1
    rprobs[which(kin_proband == 0.5)] <- 1

    # set recall probability for marry-ins to 0
    # NOTE: we will re-add essential marry-ins
    # (i.e. those needed to create ped) at a later step
    rprobs[which(kin_proband == 0)] <- 0

    # create a vector of kinship coefficients with the same length
    # as recall_probs, specified by the user
    kin_list <- 2^{-seq(from = 2, to = (length(recall_probs)+1), by = 1)}

    # use kinship coefficient to associate recall_prob with
    # appropriate family member
    for (i in 1:(length(kin_list)-1)) {
      rprobs[which(kin_proband == kin_list[i])] <- recall_probs[i]
    }
    rprobs[is.na(rprobs)] <- recall_probs[length(recall_probs)]

    #trim pedigree
    ped_trim <- ped_file[rprobs >= u, ]
  }

  # remove information and re-add individuals who cannot be recalled by proband
  # but who are required to create a complete pedigree
  d <- 0
  while (d == 0) {
    #find the dad IDs that are required but have been removed
    miss_dad  <- !is.element(ped_trim$dad_id,
                             ped_trim$ID[which(ped_trim$gender == 0)])
    readd_dad <- ped_trim$dad_id[miss_dad]
    readd_dad <- unique(readd_dad[!is.na(readd_dad)])

    #find the mom IDs that are required but have been removed
    miss_mom  <- !is.element(ped_trim$mom_id,
                             ped_trim$ID[which(ped_trim$gender == 1)])
    readd_mom <- ped_trim$mom_id[miss_mom]
    readd_mom <- unique(readd_mom[!is.na(readd_mom)])

    #check to see if we need to readd anyone
    if (length(c(readd_dad, readd_mom)) == 0) {
      d <- 1
    } else {
      #Now pull the rows containing the required parents from the original ped_file
      readd <- ped_file[which(ped_file$ID %in% c(readd_dad, readd_mom)), ]

      #remove all of their simulated data, and mark unavailable
      if (nrow(readd) >= 1) {
        readd$birth_year <- NA
        readd$onset_year <- NA
        readd$death_year <- NA
        readd$available  <- 0
      }

      #add back to pedigree
      ped_trim = rbind(ped_trim, readd)
    }
  }

  ped_trim$is_proband <- ifelse(ped_trim$ID == probandID, 1, 0)
  return(ped_trim)
}
