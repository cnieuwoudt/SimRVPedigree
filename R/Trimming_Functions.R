#' Trim Pedigree Based on Proband Recall.
#'
#' Primarily intended as an internal function, \code{trim_ped} chooses a proband and trims relatives based on the proband's probability of recalling his or her relatives.
#'
#' By default \code{recall_probs} is four times the kinship coefficient, as defined by Thompson (see references), between the proband and the probands relative, which results in a recall probability of \eqn{2^{-(n-1)}} for a relative of degree \eqn{n}. Alternatively, the user may specify a list of recall probabilities of length \eqn{l > 0}, in which case the first \emph{l-1} items in \code{recall_probs} are the respective proband recall probabilities for relatives of degree \emph{1, 2, ..., l-1}, and the \emph{l}th item in \code{recall_probs} is the proband's recall probability for all relatives of degree \strong{\emph{l} or greater}.  For example if \code{recall_probs = c(1)} all relatives will be recalled by the proband with probability 1.
#'
#'
#' Occasionally, a trimmed family member must be retained to ensure that the pedigree can be plotted.  When this occurs, family members who share a non-zero kinship coefficient with the proband are censored of all pertinent information, and will always have the following qualities:
#' \enumerate{
#'   \item availability status = 0
#'   \item affected status = NA
#'   \item birth year = NA
#'   \item onset year = NA
#'   \item death year = NA
#'   \item RR = NA
#' }
#'
#'
#' @param ped_file Data.frame. A pedigree generated by \code{sim_ped}.
#' @inheritParams sim_RVped
#'
#' @return \code{ped_trim} The trimmed pedigree.
#' @export
#'
#' @references OUR MANUSCRIPT
#' @references Thompson, E. (2000). \emph{Statistical Inference from Genetic Data on Pedigrees.} NSF-CBMS Regional Conference Series in Probability and Statistics, 6, I-169.
#'
#' @importFrom kinship2 kinship
#' @importFrom stats runif
#'
#' @examples
#' #Read in example pedigree to trim
#' data(EgPeds)
#'
#' #plot example_ped using kinship2
#' library(kinship2)
#' ex_pedigree <- pedigree(id = EgPeds$ID,
#'                         dadid = EgPeds$dadID,
#'                         momid = EgPeds$momID,
#'                         sex = (EgPeds$sex + 1),
#'                         affected = cbind(Affected = EgPeds$affected,
#'                                          Proband = EgPeds$proband,
#'                                          RV_status = EgPeds$DA1 +
#'                                                      EgPeds$DA2),
#'                         famid = EgPeds$FamID)['1']
#' plot(ex_pedigree)
#' pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
#' mtext("Original Pedigree", side = 3, line = 2)
#'
#'
#' ## Trim pedigree examples
#' #illustrate the effects of various recall_probs settings
#' Recall_Probabilities <- list(c(1),
#'                              c(1, 0),
#'                              c(1, 0.75, 0.5),
#'                              c(0.5, 0.1, 0.05))
#'
#'
#' for (k in 1:length(Recall_Probabilities)) {
#'    set.seed(2)
#'    #trim pedigree
#'    TrimPed <- trim_ped(ped_file = EgPeds[which(EgPeds$FamID == 1), ],
#'                        recall_probs = Recall_Probabilities[[k]])
#'
#'    #plot trimmed pedigree
#'    Tped <- pedigree(id = TrimPed$ID,
#'                     dadid = TrimPed$dadID,
#'                     momid = TrimPed$momID,
#'                     sex = (TrimPed$sex + 1),
#'                     affected = cbind(Affected = TrimPed$affected,
#'                                      Proband = TrimPed$proband,
#'                                      RV_status = TrimPed$DA1 + TrimPed$DA2),
#'                     famid = TrimPed$FamID)['1']
#'
#'    plot(Tped)
#'    pedigree.legend(Tped, location = "topleft",  radius = 0.25)
#'    mtext(paste0("recall_probs = (", sep = "",
#'                 paste(Recall_Probabilities[[k]], collapse = ", "), ')' ),
#'                 side = 3, line = 2 )
#' }
#'
#'
trim_ped = function(ped_file, recall_probs){

  #issue error message if proband variable not supplied with single proband selected.
  if (!("proband" %in% colnames(ped_file))) {
    stop ('please supply a proband identification variable')
  } else if (sum(ped_file$proband) != 1){
    stop ('pedigree may only contain 1 proband')
  }

  probandID <- ped_file$ID[which(ped_file$proband == 1)]

  #store info on marry-ins by ID
  marry_ins <- ped_file$ID[which(ped_file$available == 0)]

  # generate a vector of Unif(0,1) RVs, to determine who is trimmed
  u <- runif(length(ped_file$ID))

  #calculate the kinship matrix for our pedigree
  kin_mat <- kinship(ped_file,
                     id = ped_file$ID,
                     dadid = ped_file$dadID,
                     momid = ped_file$momID)

  kin_proband <- kin_mat[, which(ped_file$ID == probandID)]

  #if recall_probs have not been supplied just use 4*kinship coefficent
  if (missing(recall_probs)) {
    # keep only those individuals for whom 4*kinship coefficent with the proband
    # is greater than runif(1).  This will result in keeping parents, offspring,
    # and siblings with probability 1

    ped_trim <- ped_file[4*kin_proband >= u, ]
  } else if (length(recall_probs) == 1 & sum(recall_probs) == 1) {
    ped_trim <- ped_file
  } else {
    # create rprobs, which associates the recall probabilities
    # specified by the user with the appropriate individuals in the pedigree.

    rprobs <- rep(NA, length(ped_file$ID))

    # set recall probability for proband to 1
    rprobs[which(kin_proband == 0.5)] <- 1

    # set recall probability for marry-ins to 0
    # NOTE: we will re-add essential marry-ins
    # (i.e. those needed to create ped) at a later step
    rprobs[which(kin_proband == 0)] <- 0

    # create a vector of kinship coefficients with the same length
    # as recall_probs, specified by the user
    kin_list <- 2^{-seq(from = 2, to = (length(recall_probs)+1), by = 1)}

    # use kinship coefficient to associate recall_prob with
    # appropriate family member
    for (i in 1:(length(kin_list)-1)) {
      rprobs[which(kin_proband == kin_list[i])] <- recall_probs[i]
    }
    rprobs[is.na(rprobs)] <- recall_probs[length(recall_probs)]

    #trim pedigree
    ped_trim <- ped_file[rprobs >= u, ]
  }

  # remove information and re-add individuals who cannot be recalled by proband
  # but who are required to create a complete pedigree
  d <- 0
  while (d == 0) {
    #find the dad IDs that are required but have been removed
    miss_dad  <- !is.element(ped_trim$dadID,
                             ped_trim$ID[which(ped_trim$sex == 0)])
    readd_dad <- ped_trim$dadID[miss_dad]
    readd_dad <- unique(readd_dad[!is.na(readd_dad)])

    #find the mom IDs that are required but have been removed
    miss_mom  <- !is.element(ped_trim$momID,
                             ped_trim$ID[which(ped_trim$sex == 1)])
    readd_mom <- ped_trim$momID[miss_mom]
    readd_mom <- unique(readd_mom[!is.na(readd_mom)])

    #check to see if we need to readd anyone
    if (length(c(readd_dad, readd_mom)) == 0) {
      d <- 1
    } else {
      #Now pull the rows containing the required parents from the original ped_file
      readd <- ped_file[which(ped_file$ID %in% c(readd_dad, readd_mom)), ]

      #remove all of their simulated data, and mark unavailable
      if (nrow(readd) >= 1) {
        readd$birthYr <- NA
        readd$onsetYr <- NA
        readd$deathYr <- NA
        readd$available <- 0
        readd$affected  <- ifelse(readd$ID %in% marry_ins, 0, NA)
        readd$RR        <- ifelse(readd$ID %in% marry_ins, 1, NA)
      }

      #add back to pedigree
      ped_trim = rbind(ped_trim, readd)
    }
  }

  return(ped_trim)
}
