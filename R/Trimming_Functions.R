#' Choose proband and trim pedigree
#'
#' \code{trim_step} chooses a proband from the pedigree and trims relatives
#' based on proband recall probabilities.
#'
#'
#' @param ped_file A data.frame. The ped file generated by \code{ped_step}.
#' @param ascertain_span numeric vector of length 2. The ascertainment period,
#' i.e. first and last year of study.
#' @param recall_probs numeric.  Proband recall probabilities.  See details.
#'
#' @return The trimmed ped file
#' @export
#'
#' @importFrom kinship2 kinship
#'
#' @examples
#' part_vec <- seq(0, 100, by = 1)
#' unaffected_mort <- 0.00001 + pgamma(seq(0.16, 16, by = .16),
#'                                     shape = 9.5, scale = 1)/350
#' affected_mort <- c(0.55, 0.48, 0.37, 0.23, 0.15,
#'                    pgamma(seq(0.96, 16, by = .16), shape = 4, scale = 1.5))/300
#' Dhaz_df  <- (as.data.frame(cbind(unaffected_mort, affected_mort)))
#' Ohaz_vec <- (dgamma(seq(0.1, 10, by = .1), shape = 8, scale = 0.75))/50
#' set.seed(22)
#' ex_ped <- ped_step(onset_hazard = Ohaz_vec, death_hazard = Dhaz_df,
#'                    part = part_vec, RR = 5, founder_byears = c(1900, 1910))
#' ex_ped
#' trim_step(ex_ped, ascertain_span = c(1990, 2015))
#' trim_step(ex_ped, ascertain_span = c(1990, 2015), recall_probs = c(1, 0.9, 0))
trim_step = function(ped_file, ascertain_span, recall_probs){
  #First we must randomly choose an individual who experienced
  #onset during the time span defined by ascertain_span

  AffIDs = ped_file[which(ped_file$affected == 1),
                    which(colnames(ped_file) %in% c("onset_year", "ID"))]
  AffIDs$poss_proband = ifelse(AffIDs$onset_year %in% ascertain_span[1]:ascertain_span[2], 1, 0)


  if (sum(AffIDs$poss_proband) == 1) {
    #only 1 available proband
    probandID = AffIDs$ID[which(AffIDs$poss_proband == 1)]
  } else if ( sum(abs(AffIDs$poss_proband - 1)) > 0 ) {
    #multiple available probands but 2 affected condition
    #already met by start of ascertainment period
    probandID = sample(size = 1, x = AffIDs$ID[which(AffIDs$poss_proband == 1)])
  } else{
    #no affecteds before ascertainment period
    AffIDs$poss_proband[which.min(AffIDs$onset_year)] = 0
    probandID =  sample(size = 1, x = AffIDs$ID[which(AffIDs$poss_proband == 1)])
  }

  #generate a vector of Unif(0,1) RVs, these will be used to
  # determine who is trimmed and who is kept
  u = runif(length(ped_file$ID))

  #calculate the kinship matrix for our pedigree
  kin.mat = kinship(ped_file,
                    id = ped_file$ID,
                    dadid = ped_file$dad_id,
                    momid = ped_file$mom_id)

  kin.proband = kin.mat[, which(ped_file$ID == probandID)]

  if (missing(recall_probs)) {
    #Now, we keep only those individuals for whom the kinship coefficent with the proband*4
    # is greater than runif(1).  This will result in keeping parents, offspring, and siblings
    # with probability 1
    ped.trim = ped_file[kin.proband/0.25 >= u, ]
  } else {
    #This next chuck (where rprobs is created) associates the recall probabilities
    # specified by the user with the appropriate individuals in the pedigree.
    rprobs = rep(NA, length(ped_file$ID))
    #set recall probability for proband to 1
    rprobs[which(kin.proband == 0.5)] = 1
    #set recall probability to non-related individuals to 0
    # NOTE: those who need to be added back in will be later
    rprobs[which(kin.proband == 0)] = 0

    #create a vector of kinship coefficient with the same length as the recall.prob
    # vector specified by the user
    kin.list = 2^{-seq(from = 2, to = (length(recall_probs)+1), by = 1)}

    for (i in 1:(length(kin.list)-1)) {
      rprobs[which(kin.proband == kin.list[i])] = recall_probs[i]
    }
    rprobs[is.na(rprobs)] = recall_probs[length(recall_probs)]

    ped.trim = ped_file[rprobs >= u, ]
  }

  d = 0
  while (d <= 0) {
    #find the dad IDs that are required but have been removed
    readd.dad = ped.trim$dad_id[!is.element(ped.trim$dad_id,
                                            ped.trim$ID[which(ped.trim$gender == 0)])]

    #find the mom IDs that are required but have been removed
    readd.mom = ped.trim$mom_id[!is.element(ped.trim$mom_id,
                                            ped.trim$ID[which(ped.trim$gender == 1)])]

    #Now pull the rows containing the required parents from the original ped_file
    readd = ped_file[which(ped_file$ID %in%
                             c(readd.dad[!is.na(readd.dad)],
                               readd.mom[!is.na(readd.mom)])), ]
    #and remove all of their simulated data, and mark unavailable
    if (nrow(readd) >= 1) {
      readd$birth_year = NA
      readd$onset_year = NA
      readd$death_year = NA
      readd$available  = 0
    }

    ped.trim = rbind(ped.trim, readd)

    #see if we are still missing any moms or dads
    readd.dad = ped.trim$dad_id[!is.element(ped.trim$dad_id,
                                            ped.trim$ID[which(ped.trim$gender == 0)])]
    readd.mom = ped.trim$mom_id[!is.element(ped.trim$mom_id,
                                            ped.trim$ID[which(ped.trim$gender == 1)])]


    if (sum(!is.na(readd.dad)) > 0 | sum(!is.na(readd.mom)) > 0) {
      d = 0
    } else {d = 1}
  }

  ped.trim$is_proband = ifelse(ped.trim$ID == probandID, 1, 0)
  return(ped.trim)
}
