#' Trim pedigree based on proband recall
#'
#' Primarily intended as an internal function, \code{trim.ped} chooses a proband and trims relatives based on the proband's probability of recalling his or her relatives.
#'
#' By default \code{recall_probs} is four times the kinship coefficient, as defined by Thompson (see references), between the proband and the probands relative, which results in a recall probability of \eqn{2^{-(n-1)}} for a relative of degree \eqn{n}. Alternatively, the user may specify a list of recall probabilities of length \eqn{l > 0}, in which case the first \emph{l-1} items in \code{recall_probs} are the respective proband recall probabilities for relatives of degree \emph{1, 2, ..., l-1}, and the \emph{l}th item in \code{recall_probs} is the proband's recall probability for all relatives of degree \strong{\emph{l} or greater}.  For example if \code{recall_probs = c(1)} all relatives will be recalled by the proband with probability 1.
#'
#'
#' Occasionally, a trimmed family member must be retained to ensure that the pedigree can be plotted.  When this occurs, family members who share a non-zero kinship coefficient with the proband are censored of all pertinent information, and will always have the following qualities:
#' \enumerate{
#'   \item availability status = 0
#'   \item affected status = NA
#'   \item birth year = NA
#'   \item onset year = NA
#'   \item death year = NA
#'   \item RR = NA
#' }
#'
#' Users who wish to use \code{trim.ped} for pedigrees not generated by \code{sim_ped} or \code{sim_RVped} must use \code{\link{new.ped}} to create an object of class \code{ped}.  The \code{ped} object \emph{must} contain the following variables for each pedigree member:
#' \tabular{lll}{
#' \strong{name} \tab \strong{type} \tab \strong{description} \cr
#' \code{FamID} \tab numeric \tab family identification number \cr
#' \code{ID} \tab numeric \tab individual identification number \cr
#' \code{dadID} \tab numeric \tab identification number of father \cr
#' \code{momID} \tab numeric \tab identification number of mother \cr
#' \code{sex} \tab numeric \tab gender identification; if male \code{sex = 0}, if female \code{sex = 1} \cr
#' \code{affected} \tab logical \tab disease-affection status, \code{affected  = TRUE} if affected by disease , and \code{FALSE} otherwise, \cr
#' \tab\tab\cr
#' \code{birthYr} \tab numeric \tab the individual's birth year.\cr
#' \code{onsetYr} \tab numeric \tab the individual's disease onset year, when applicable.\cr
#' \code{deathYr} \tab numeric \tab the individual's death year, when applicable.\cr
#' \code{proband} \tab logical \tab a proband identifier: \code{proband = TRUE} if the individual is the proband, and \code{FALSE} otherwise.\cr
#' \code{RR} \tab numeric \tab the individual's relative risk of disease. \cr
#' \code{available} \tab logical \tab availibility status; \cr
#' \tab\tab \code{available = TRUE} if available, and \code{FALSE} otherwise. \cr
#' }
#'
#' @inheritParams sim_RVped
#' @inheritParams censor.ped
#'
#'
#' @return \code{ped_trim} The trimmed pedigree.
#' @seealso \code{\link{sim_RVped}}, \code{\link{sim_ped}}, \code{\link{new.ped}}
#' @export
#'
#' @references OUR MANUSCRIPT
#' @references Thompson, E. (2000). \emph{Statistical Inference from Genetic Data on Pedigrees.} NSF-CBMS Regional Conference Series in Probability and Statistics, 6, I-169.
#'
#' @importFrom kinship2 kinship
#' @importFrom stats runif
#'
#' @examples
#' #Read in example pedigree to trim
#' data(EgPeds)
#' egPeds <- new.ped(EgPeds)
#'
#' #plot example_ped using kinship2
#' ex_pedigree <- ped2pedigree(egPeds)
#'
#' library(kinship2)
#' plot(ex_pedigree['1'])
#' pedigree.legend(ex_pedigree['1'], location = "topleft",  radius = 0.25)
#' mtext("Original Pedigree", side = 3, line = 2)
#'
#'
#' ## Trim pedigree examples
#' # Illustrate the effect of various settings for recall_probs
#' Recall_Probabilities <- list(c(1),
#'                              c(1, 0),
#'                              c(1, 0.75, 0.5),
#'                              c(0.5, 0.1, 0.05))
#'
#'
#' for (k in 1:length(Recall_Probabilities)) {
#'    set.seed(2)
#'    #trim pedigree
#'    TrimPed <- trim.ped(ped_file = egPeds[egPeds$FamID == 1, ],
#'                        recall_probs = Recall_Probabilities[[k]])
#'
#'    #plot trimmed pedigree
#'    Tped <- ped2pedigree(TrimPed)
#'
#'    plot(Tped)
#'    pedigree.legend(Tped, location = "topleft",  radius = 0.25)
#'    mtext(paste0("recall_probs = (", sep = "",
#'                 paste(Recall_Probabilities[[k]], collapse = ", "), ')' ),
#'                 side = 3, line = 2 )
#' }
#'
#'
trim.ped = function(ped_file, recall_probs){

  if (!is.ped(ped_file)) {
    stop("\n \n Expecting a ped object. \n Please use new.ped to create an object of class ped.")
  }

  #issue error message if proband variable not supplied with single proband selected.
  if (!("proband" %in% colnames(ped_file))) {
    stop ('please supply a proband identification variable')
  } else if (sum(ped_file$proband) != 1){
    stop ('pedigree may not contain mulitple probands, please ensure that a single individual is designated as the proband ')
  }

  probandID <- ped_file$ID[ped_file$proband]

  #store info on marry-ins by ID
  marry_ins <- ped_file$ID[ped_file$available == FALSE]

  # generate a vector of Unif(0,1) RVs, to determine who is trimmed
  u <- runif(length(ped_file$ID))

  #calculate the kinship matrix for our pedigree
  kin_mat <- kinship(ped_file,
                     id = ped_file$ID,
                     dadid = ped_file$dadID,
                     momid = ped_file$momID)

  kin_proband <- kin_mat[, ped_file$ID == probandID]

  #if recall_probs have not been supplied just use 4*kinship coefficent
  if (missing(recall_probs)) {
    # keep only those individuals for whom 4*kinship coefficent with the proband
    # is greater than runif(1).  This will result in keeping parents, offspring,
    # and siblings with probability 1

    ped_trim <- ped_file[4*kin_proband >= u, ]
  } else if (length(recall_probs) == 1 & sum(recall_probs) == 1) {
    ped_trim <- ped_file
  } else {
    # create rprobs, which associates the recall probabilities
    # specified by the user with the appropriate individuals in the pedigree.

    rprobs <- rep(NA, length(ped_file$ID))

    # set recall probability for proband to 1
    rprobs[kin_proband == 0.5] <- 1

    # set recall probability for marry-ins to 0
    # NOTE: we will re-add essential marry-ins
    # (i.e. those needed to create ped) at a later step
    rprobs[kin_proband == 0] <- 0

    # create a vector of kinship coefficients with the same length
    # as recall_probs, specified by the user
    kin_list <- 2^{-seq(from = 2, to = (length(recall_probs)+1), by = 1)}

    # use kinship coefficient to associate recall_prob with
    # appropriate family member
    for (i in 1:(length(kin_list)-1)) {
      rprobs[kin_proband == kin_list[i]] <- recall_probs[i]
    }
    rprobs[is.na(rprobs)] <- recall_probs[length(recall_probs)]

    #trim pedigree
    ped_trim <- ped_file[rprobs >= u, ]
  }

  # remove information and re-add individuals who cannot be recalled by proband
  # but who are required to create a complete pedigree
  d <- 0
  while (d == 0) {
    #find the dad IDs that are required but have been removed
    miss_dad  <- !is.element(ped_trim$dadID,
                             ped_trim$ID[ped_trim$sex == 0])
    readd_dad <- ped_trim$dadID[miss_dad]
    readd_dad <- unique(readd_dad[!is.na(readd_dad)])

    #find the mom IDs that are required but have been removed
    miss_mom  <- !is.element(ped_trim$momID,
                             ped_trim$ID[ped_trim$sex == 1])
    readd_mom <- ped_trim$momID[miss_mom]
    readd_mom <- unique(readd_mom[!is.na(readd_mom)])

    #check to see if we need to readd anyone
    if (length(c(readd_dad, readd_mom)) == 0) {
      d <- 1
    } else {
      #Now pull the rows containing the required parents from the original ped_file
      readd <- ped_file[ped_file$ID %in% c(readd_dad, readd_mom), ]

      #remove all of their simulated data, and mark unavailable
      if (nrow(readd) >= 1) {
        readd$birthYr <- NA
        readd$onsetYr <- NA
        readd$deathYr <- NA
        readd$available <- F
        readd$RR        <- NA
        readd$affected  <- ifelse(readd$ID %in% marry_ins, F, NA)
      }

      #add back to pedigree
      ped_trim = rbind(ped_trim, readd)
    }
  }

  return(ped_trim)
}
