#' Trim Pedigree Based on Proband Recall.
#'
#' Primarily intended as an internal function, \code{trim_ped} chooses a proband and trims relatives based on the proband's probability of recalling his or her relatives.
#'
#' By default \code{recall_probs} is four times the kinship coefficient between the proband and the probands relative, which results in a recall probability of \eqn{2^{-(n-1)}} for a relative of degree \eqn{n}. Alternatively, the user may specify a list of recall probabilities of length \eqn{l > 0}, in which case the first \emph{l-1} items in \code{recall_probs} are the respective proband recall probabilities for relatives of degree \emph{1, 2, ..., l-1}, and the \emph{l}th item in \code{recall_probs} is the proband's recall probability for all relatives of degree \strong{\emph{l} or greater}.  For example if \code{recall_probs = c(1)} all relatives will be recalled by the proband with probability 1.
#'
#'
#' Occasionally, a trimmed family member must be retained to ensure pedigree can be plotted.  When this occurs, these family members are censored of all pertinent information, and will always have the following qualities:
#' \enumerate{
#'   \item availability status = 0
#'   \item affected status = NA
#'   \item birth year = NA
#'   \item onset year = NA
#'   \item death year = NA
#' }
#'
#'
#' @param ped_file Data.frame. A pedigree generated by \code{sim_ped}.
#' @inheritParams sim_RVped
#'
#' @return \code{ped_trim} The trimmed pedigree.
#' @export
#'
#' @importFrom kinship2 kinship
#' @importFrom stats runif
#'
#' @examples
#' #Read in example pedigree to trim
#' data(ExamplePedigrees)
#'
#' #plot example_ped using kinship2
#' library(kinship2)
#' ex_pedigree <- pedigree(id = ExamplePedigrees$ID,
#'                         dadid = ExamplePedigrees$dad_id,
#'                         momid = ExamplePedigrees$mom_id,
#'                         sex = (ExamplePedigrees$gender + 1),
#'                         affected = cbind(Affected = ExamplePedigrees$affected,
#'                                          RV_status = ExamplePedigrees$DA1 +
#'                                                      ExamplePedigrees$DA2),
#'                         famid = ExamplePedigrees$FamID)['1']
#' plot(ex_pedigree)
#' pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
#' mtext("Original Pedigree", side = 3, line = 2)
#'
#'
#' ## Trim pedigree examples
#' #illustrate the effects of various recall_probs settings
#' Recall_Probabilities <- list(r1 = c(1, 0),
#'                              r2 = c(1),
#'                              r3 = c(1, 0.5, 0.25, 0.125))
#'
#'
#' for (k in 1:length(Recall_Probabilities)) {
#'    set.seed(2)
#'    #trim pedigree
#'    TrimPed <- trim_ped(ped_file = ExamplePedigrees[which(ExamplePedigrees$FamID == 1), ],
#'                        recall_probs = Recall_Probabilities[[k]])
#'
#'    #plot trimmed pedigree
#'    Tped <- pedigree(id = TrimPed$ID,
#'                     dadid = TrimPed$dad_id,
#'                     momid = TrimPed$mom_id,
#'                     sex = (TrimPed$gender + 1),
#'                     affected = cbind(Affected = TrimPed$affected,
#'                                      Proband = TrimPed$is_proband,
#'                                      RV_status = TrimPed$DA1 + TrimPed$DA2),
#'                     famid = TrimPed$FamID)['1']
#'
#'    plot(Tped)
#'    pedigree.legend(Tped, location = "topleft",  radius = 0.25)
#'    mtext(paste0("recall_probs = (", sep = "",
#'                 paste(Recall_Probabilities[[k]], collapse = ", "), ')' ),
#'                 side = 3 )
#' }
#'
#'
trim_ped = function(ped_file, recall_probs){

  #issue error message if proband variable not supplied with single proband selected.
  if (!("proband" %in% colnames(ped_file))) {
    stop ('please supply a proband identification variable')
  } else if (sum(ped_file$proband) != 1){
    stop ('pedigree may only contain 1 proband')
  }

  probandID <- ped_file$ID[which(ped_file$proband == 1)]

  # generate a vector of Unif(0,1) RVs, to determine who is trimmed
  u <- runif(length(ped_file$ID))

  #calculate the kinship matrix for our pedigree
  kin_mat <- kinship(ped_file,
                     id = ped_file$ID,
                     dadid = ped_file$dad_id,
                     momid = ped_file$mom_id)

  kin_proband <- kin_mat[, which(ped_file$ID == probandID)]

  #if recall_probs have not been supplied just use 4*kinship coefficent
  if (missing(recall_probs)) {
    # keep only those individuals for whom 4*kinship coefficent with the proband
    # is greater than runif(1).  This will result in keeping parents, offspring,
    # and siblings with probability 1

    ped_trim <- ped_file[4*kin_proband >= u, ]
  } else if (sum(recall_probs) == 1 & length(recall_probs) == 1) {
    ped_trim <- ped_file
  } else {
    # create rprobs, which associates the recall probabilities
    # specified by the user with the appropriate individuals in the pedigree.

    rprobs <- rep(NA, length(ped_file$ID))

    # set recall probability for proband to 1
    rprobs[which(kin_proband == 0.5)] <- 1

    # set recall probability for marry-ins to 0
    # NOTE: we will re-add essential marry-ins
    # (i.e. those needed to create ped) at a later step
    rprobs[which(kin_proband == 0)] <- 0

    # create a vector of kinship coefficients with the same length
    # as recall_probs, specified by the user
    kin_list <- 2^{-seq(from = 2, to = (length(recall_probs)+1), by = 1)}

    # use kinship coefficient to associate recall_prob with
    # appropriate family member
    for (i in 1:(length(kin_list)-1)) {
      rprobs[which(kin_proband == kin_list[i])] <- recall_probs[i]
    }
    rprobs[is.na(rprobs)] <- recall_probs[length(recall_probs)]

    #trim pedigree
    ped_trim <- ped_file[rprobs >= u, ]
  }

  # remove information and re-add individuals who cannot be recalled by proband
  # but who are required to create a complete pedigree
  d <- 0
  while (d == 0) {
    #find the dad IDs that are required but have been removed
    miss_dad  <- !is.element(ped_trim$dad_id,
                             ped_trim$ID[which(ped_trim$gender == 0)])
    readd_dad <- ped_trim$dad_id[miss_dad]
    readd_dad <- unique(readd_dad[!is.na(readd_dad)])

    #find the mom IDs that are required but have been removed
    miss_mom  <- !is.element(ped_trim$mom_id,
                             ped_trim$ID[which(ped_trim$gender == 1)])
    readd_mom <- ped_trim$mom_id[miss_mom]
    readd_mom <- unique(readd_mom[!is.na(readd_mom)])

    #check to see if we need to readd anyone
    if (length(c(readd_dad, readd_mom)) == 0) {
      d <- 1
    } else {
      #Now pull the rows containing the required parents from the original ped_file
      readd <- ped_file[which(ped_file$ID %in% c(readd_dad, readd_mom)), ]

      #remove all of their simulated data, and mark unavailable
      if (nrow(readd) >= 1) {
        readd$birth_year <- NA
        readd$onset_year <- NA
        readd$death_year <- NA
        readd$affected  <- NA
        readd$available <- 0
      }

      #add back to pedigree
      ped_trim = rbind(ped_trim, readd)
    }
  }

  return(ped_trim)
}
