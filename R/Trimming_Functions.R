#' Choose a proband and trim pedigree.
#'
#' \code{trim_pedigree} chooses a proband from the pedigree and trims relatives
#' based on the proband's recall probability of that relative.
#'
#' By default \code{recall_probs} is 4 times the kinship coefficent between the
#' proband and the probands relative, which results in a recall probability of
#' \eqn{2^{-(n-1)}} for a relative of degree \eqn{n}. Alternatively, the user may
#' specify a list of recall probabilites of length \eqn{l > 0}, in which case
#' the first \emph{l-1} items in \code{recall_probs} are the respective proband
#' recall probabilites for relatives of degree \emph{1, 2, ..., l-1}, and the
#' \emph{l}th item in \code{recall_probs} is the proband's recall probability for
#' all relatives of degree \strong{\emph{l} or greater}.  For example if
#' \code{recall_probs = c(1)} all relatives will be recalled by the proband with
#' probability 1.
#'
#' Within the \code{trim_pedigree} function, the argument \code{num_affected} serves to determine which affected members may be selected as the proband, not to ensure the number of affected members in the trimmed pedigree, as in \code{sim_RVpedigree}.
#' For example, if there are only two affected members and \code{num_affected = 2}, then \code{trim_pedigree} will choose as the proband the second individual to experience onset, so that at the time of ascertainment the pedigree would have had two affected family members.  If \code{recall_probs != c(1)}, it is possible that proband will not recall the other affected.  Hence, the trimmed pedigree may have only 1 affected family member.
#'
#'
#' @param ped_file A data.frame. The ped file generated by \code{ped_step}.
#' @param ascertain_span numeric vector of length 2. The ascertainment period,
#' i.e. first and last year of study.
#' @param num_affected Numeric.  Number of affected individuals in ascertained pedigree. See details.
#' @param recall_probs Numeric.  Proband recall probabilities.  See details.
#'
#' @return The trimmed ped file
#' @export
#'
#' @importFrom kinship2 kinship
#' @importFrom stats runif
#'
#' @examples
#' #Read in example pedigree to trim
#' data(exp_peds)
#'
#' #plot example_ped using kinship2
#' library(kinship2)
#' ex_pedigree <- pedigree(id = exp_peds$ID,
#'                         dadid = exp_peds$dad_id,
#'                         momid = exp_peds$mom_id,
#'                         sex = (exp_peds$gender + 1),
#'                         affected = cbind(Affected = exp_peds$affected,
#'                                          RV_status = exp_peds$DA1 +
#'                                                      exp_peds$DA2),
#'                         famid = exp_peds$FamID)['1']
#' plot(ex_pedigree)
#' pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
#' mtext("Original Pedigree", side = 3, line = 2)
#'
#'
#' ## Trim pedigree examples
#' #define lists of various trimming parameters to
#' #illustrate the effects of various settings
#' Recall_Probabilities <- list(r1 = c(1, 0),
#'                              r2 = c(1),
#'                              r3 = c(1, 0.5, 0.25, 0.125),
#'                              r4 = c(1, 0.5, 0.25, 0.125),
#'                              r5 = c(1, 0.5, 0.25, 0.125))
#'
#' Number_Affected <- c(2, 2, 2, 2, 3)
#' Ascertainment_Span <- list(span1 = c(2005, 2015),
#'                            span2 = c(2005, 2015),
#'                            span3 = c(2005, 2015),
#'                            span4 = c(2000, 2015),
#'                            span5 = c(2000, 2015))
#'
#'
#' for (k in 1:length(Number_Affected)) {
#'    set.seed(2)
#'    #trim pedigree
#'    TrimPed <- trim_pedigree(ped_file = exp_peds[which(exp_peds$FamID == 1), ],
#'                             ascertain_span = Ascertainment_Span[[k]],
#'                             num_affected = Number_Affected[[k]],
#'                             recall_probs = Recall_Probabilities[[k]])
#'
#'    #plot trimmed pedigree
#'    Tped <- pedigree(id = TrimPed$ID,
#'                     dadid = TrimPed$dad_id,
#'                     momid = TrimPed$mom_id,
#'                     sex = (TrimPed$gender + 1),
#'                     affected = cbind(Affected = TrimPed$affected,
#'                                      Proband = TrimPed$is_proband,
#'                                      RV_status = TrimPed$DA1 + TrimPed$DA2),
#'                     famid = TrimPed$FamID)['1']
#'
#'    plot(Tped)
#'    pedigree.legend(Tped, location = "topleft",  radius = 0.25)
#'    mtext(paste0("recall_probs = (", sep = "",
#'                 paste(Recall_Probabilities[[k]], collapse = ", "),
#'                 ")\n ascertain_span = (",
#'                 paste(Ascertainment_Span[[k]], collapse = ", "),
#'                 ")\n num_affected = ", Number_Affected[[k]]),
#'                 side = 3 )
#' }
#'
#'
trim_pedigree = function(ped_file, ascertain_span, num_affected, recall_probs){
  #First we must randomly choose a proband from the individuals who
  #experienced onset during ascertain_span, keeping in mind that there should
  #be num_affected - 1 individuals who have experienced onset before the proband
  #Gather info on probands in AffIDs
  AffIDs <- ped_file[which(ped_file$affected == 1),
                    which(colnames(ped_file) %in% c("onset_year", "ID"))]
  AffIDs <- AffIDs[order(AffIDs$onset_year), ]
  AffIDs$poss_proband <- ifelse(AffIDs$onset_year %in%
                                  ascertain_span[1]:ascertain_span[2], 1, 0)

  #issue error message if num_affected violated.
  if (nrow(AffIDs) < num_affected) stop ('num_affected condition not met')

  if (sum(AffIDs$poss_proband) == 1) {
    #only 1 available proband
    probandID <- AffIDs$ID[which(AffIDs$poss_proband == 1)]
  } else if (sum(abs(AffIDs$poss_proband - 1)) > (num_affected - 1)) {
    #multiple available probands and the n-1 affected condition has already
    #been met by start of ascertainment period, so simply choose randomly
    #amongst available probands
    probandID <- sample(size = 1,
                        x = AffIDs$ID[which(AffIDs$poss_proband == 1)])
  } else {
    #no affecteds before ascertainment period, must choose from among
    #the nth or greater to experience onset
    AffIDs$poss_proband[1:(num_affected - 1)] <- 0
    #must write additional if statement here because of R's interesting
    #take on how sample should work when there is only one 1 to sample from....
    if (sum(AffIDs$poss_proband) == 1) {
      probandID <- AffIDs$ID[which(AffIDs$poss_proband == 1)]
    } else {
      probandID <-  sample(size = 1,
                           x = AffIDs$ID[which(AffIDs$poss_proband == 1)])
    }
  }

  # generate a vector of Unif(0,1) RVs, to determine who is trimmed
  u <- runif(length(ped_file$ID))

  #calculate the kinship matrix for our pedigree
  kin_mat <- kinship(ped_file,
                     id = ped_file$ID,
                     dadid = ped_file$dad_id,
                     momid = ped_file$mom_id)

  kin_proband <- kin_mat[, which(ped_file$ID == probandID)]

  #if recall_probs have not been supplied just use 4*kinship coefficent
  if (missing(recall_probs)) {
    # keep only those individuals for whom 4*kinship coefficent with the proband
    # is greater than runif(1).  This will result in keeping parents, offspring,
    # and siblings with probability 1

    ped_trim <- ped_file[4*kin_proband >= u, ]
  } else if (sum(recall_probs) == 1 & length(recall_probs) == 1) {
    ped_trim <- ped_file
  } else {
    # create rprobs, which associates the recall probabilities
    # specified by the user with the appropriate individuals in the pedigree.

    rprobs <- rep(NA, length(ped_file$ID))

    # set recall probability for proband to 1
    rprobs[which(kin_proband == 0.5)] <- 1

    # set recall probability for marry-ins to 0
    # NOTE: we will re-add essential marry-ins
    # (i.e. those needed to create ped) at a later step
    rprobs[which(kin_proband == 0)] <- 0

    # create a vector of kinship coefficients with the same length
    # as recall_probs, specified by the user
    kin_list <- 2^{-seq(from = 2, to = (length(recall_probs)+1), by = 1)}

    # use kinship coefficient to associate recall_prob with
    # appropriate family member
    for (i in 1:(length(kin_list)-1)) {
      rprobs[which(kin_proband == kin_list[i])] <- recall_probs[i]
    }
    rprobs[is.na(rprobs)] <- recall_probs[length(recall_probs)]

    #trim pedigree
    ped_trim <- ped_file[rprobs >= u, ]
  }

  # remove information and re-add individuals who cannot be recalled by proband
  # but who are required to create a complete pedigree
  d <- 0
  while (d == 0) {
    #find the dad IDs that are required but have been removed
    miss_dad  <- !is.element(ped_trim$dad_id,
                             ped_trim$ID[which(ped_trim$gender == 0)])
    readd_dad <- ped_trim$dad_id[miss_dad]
    readd_dad <- unique(readd_dad[!is.na(readd_dad)])

    #find the mom IDs that are required but have been removed
    miss_mom  <- !is.element(ped_trim$mom_id,
                             ped_trim$ID[which(ped_trim$gender == 1)])
    readd_mom <- ped_trim$mom_id[miss_mom]
    readd_mom <- unique(readd_mom[!is.na(readd_mom)])

    #check to see if we need to readd anyone
    if (length(c(readd_dad, readd_mom)) == 0) {
      d <- 1
    } else {
      #Now pull the rows containing the required parents from the original ped_file
      readd <- ped_file[which(ped_file$ID %in% c(readd_dad, readd_mom)), ]

      #remove all of their simulated data, and mark unavailable
      if (nrow(readd) >= 1) {
        readd$birth_year <- NA
        readd$onset_year <- NA
        readd$death_year <- NA
        readd$available  <- 0
      }

      #add back to pedigree
      ped_trim = rbind(ped_trim, readd)
    }
  }

  #assign proband identifier
  ped_trim$proband <- ifelse(ped_trim$ID == probandID, 1, 0)

  return(ped_trim)
}
