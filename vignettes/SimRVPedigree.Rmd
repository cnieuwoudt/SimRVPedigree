---
title: "SimRVPedigree"
author: "Christina Nieuwoudt, Jinko Graham"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{SimRVPedigree}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body{ /* Normal  */
   font-size: 20px;
}
</style>

# Table of contents
1. [Introduction](#introduction)
2. [Individual and Pedigree Specific Assumptions](#PedLevel)
3. [Study Design/Ascertainment Scheme Features](#StudyLevel)
4. [`sim_RVped()` Arguments](#simRVped)
5. [Example Application to Family-Based Study](#Example)
6. [Parallel Processing Example](#ParProcExample)
7. [References](#Ref)


#1. Introduction <a name="introduction"></a>

Family-based studies to identify genetic susceptibility factors associated with rare diseases have received much attention in recent years.  This resurgence in popularity is due to the fact that family-based studies have more power to detect rare variants, require smaller sample sizes, and can more accurately detect sequencing errors than case-control studies [8].  However, garnering a suitable number of families for analysis could require decades of continued collaboration between researchers and clinicians.  As a result, these studies are difficult to replicate.  The `SimRVPedigree` package aims to address this problem by providing a platform to randomly simulate families ascertained to contain multiple relatives affected by a rare disease. 

The distinguishing feature of the `SimRVPedigree` package is that it aims to mimic the process of family development, while allowing users to incorporate multiple facets of family ascertainment.  To illustrate and fully explain these features, in the next two sections, we will first discuss the process of pedigree simulation, followed by a full exposition of the study design features available to users.  Later we provide an example, which illustrates an application of `SimRVPedigree` to simulate pedigrees for a specific family-based study.

#2. Individual and Pedigree Specific Assumptions <a name="PedLevel"></a>
1. Given a sample of pedigrees we allow for the possibility that different families may segregate different rare variants, but make the assumption that within a family genetic cases are due to a shared rare variant that increases disease susceptibility.

2. We assume that the variant is rare enough that it has been introduced by one founder.  We begin the simulation of the pedigree with this founder, and transmit the rare variant from parent to offspring according to Mendel's laws.

3. We assume that, given an individual's current age, their time to disease onset is the waiting time in a non-homogeneous Poisson process with an age-specific hazard rate that follows a proportional hazards model.  In this model, individuals who have NOT inherited the rare variant experience disease onset according to the baseline (or population) hazard rate of disease.  On the other hand, individuals who have inherited the rare variant are assumed to have an increased risk of disease relative to those who have not inherited it.  The user is expected to supply the baseline hazard rate of disease, as well as the relative risk of disease for genetic cases.  

4. We assume that, given an individual's current age, their time to death is the waiting time in a non-homogeneous Poisson process with age-specific hazard rate determined by their affection status.  We assume that unaffected individuals experience death according to the age-specific hazard rate for death in the unaffected population; if the disease of interest is sufficiently rare, the user may instead choose to substitute the population age-specific hazard rate for death in the general population.  We assume that affected individuals experience death according to the age-specific hazard rate for death in the affected population.  The user is expected to supply both of these age-specific hazard rates.

5. We assume that, given an individual's current age, their time to reproduction is the waiting time in a homogeneous Poisson process.  That is, we assume that individuals reproduce at uniform rate during their reproductive years.  For example, one's reproductive years may span from age 18 to age 45 years.  We do not allow for offspring to be produced outside of the birth range specified by the user.

6. We do not model disease remission. Rather, we impose the restriction that individuals may only experience disease onset once, and remain affected from that point on.  After disease onset occurs the affected hazard rate for death is applied.

#3. Study Design/Ascertainment Scheme Features <a name="StudyLevel"></a>
The `sim_RVped()` function is used to randomly simulate families ascertained to have multiple affected relatives. The study design features available to the user are specified via the following arguments:

1. `num_affected`: the minimum number of relatives affected by the disease of interest in each pedigree. 

2. `ascertain_span`: The span, in years, in which the family-based study ascertains families for analysis.  We require that the proband, i.e. the affected family member who enlists the family for analysis, experienced disease onset during the ascertainment period.  Additionally, when `num_affected` = $n$ affected family members are requested, we require that at the time of ascertainment the proband is at least the $n^{th}$ affected.  For example, suppose that we would like to mimic a family-based study that requires at least 3 affected members per family.  Presumably, the family would be ascertained for study when the proband, upon speaking to the clinician, informs the clinician that he or she is aware of at least 2 family members who are also affected by the disease of interest.  We also require that this condition is met when simulating families with incomplete ascertainment, discussed next.

4. `recall_probs`: the proband's recall probabilities, $\rho = (\rho_1, \rho_2, ..., \rho_n)$, for relatives where $$\rho_i = \left\{ \begin{array}{ll}
                \text{proband recall probability for a relative of degree } i & \text{for } i = 1, 2, ..., n-1;\\
                \text{proband recall probability for a relative of degree $n$ or greater} & \text{for } i = n.\end{array} \right.$$
This option is included to allow researchers to model the possibility that a proband either cannot provide a complete family history or that they explicitly request that certain family members not be contacted.  To simulate fully ascertained families simply specify `recall_probs = c(1)` so that the proband's recall probability of all relatives is 1.  If `recall_probs` is unspecified, the default values of four times the kinship coefficient, as defined in [7], between the proband and his or her relatives are assumed, which has the effect of retaining all first degree relatives with probability 1, retaining all second degree relatives with probability 0.5, retaining all third degree relatives with probability 0.25, etc.

3. `stop_year`: the stop year represents either: the year that the study ends or the last full year that data have been collected.  All events that occur after the stop year are censored.

#4. `sim_RVped()` Arguments <a name="simRVped"></a>

To simulate a pedigree with `sim_RVped` the user must specify:

1. `onset_hazard`: the population age-specific hazard rate for disease.
2. `death_hazard`: a data frame with:
     1. column 1: the age-specific hazard rate for death in the unaffected population.
     2. column 2: the age-specific hazard rate for death in the affected population.
   If the disease of interest is sufficiently rare, at the user's discretion, column 2 may be approximated by the population age-specific hazard rate for death. 
3. `part`: a partition of ages over which to apply the age-specific hazard rates in `onset_hazard` and `death_hazard`.
4. `RR`: the relative risk of disease for individuals who have inherited the rare variant. 
5. `FamID`: the family ID to assign to the simulated pedigree.
6. `founder_byears`: the span of years from which to simulate, uniformly, the founder's birth year.
7. `ascertain_span`: the year span of the ascertainment period.  This period represents the range of years during which the proband developed disease and the family would have been ascertained for multiple affected relatives. 
8. `num_affected`: the minimum number of affected individuals in the pedigree. 

Optional arguments:

9. `recall_probs`: the proband's recall probabilities for relatives, as described in section 3.  If missing, four times kinship coefficient between the proband and the relative is used.
10. `birth_range`: the minimum and maximum allowable ages, in years, between which individuals may reproduce.  If missing, it is assumed that `birth_range = c(18, 45)`.
11. `NB_params`: the size and probability parameters of the negative binomial distribution used to model the number of children per household. If missing, it is assumed that `NB_params = c(2, 4/7)`, this setting is due to the findings of Kojima and Kelleher [2].
12. `stop_year`: the last year of study.  If missing, the current year is used.

We will illustrate the usage and output of this function in the next section.

#5. Example Application to Family-Based Study <a name="Example"></a>
Suppose that, from 2000 to 2015, researchers collected data on 150 families that contain at least two, related individuals who are affected by a lymphoid cancer.  Researchers believe that affected members within a family share a rare variant that increases disease susceptibility.  While they are not willing to assume that the same rare variant is segregating in all families, they are willing to make the simplifying assumption that all individuals carrying a genetic susceptibility variant share the same relative risk of disease.  They also believe that carriers of the susceptibility variant are 10 times more likely to develop lymphoid cancer than non-carriers.  

Researchers confident that all affected family members have been fully ascertained.  Upon inspecting the founders in their ascertained families, they see that all were born between 1900 and 1980.

Based on the description of the family-based study described above, and referring to the input requirements in the last section, to randomly simulate families likely to be ascertained by this study with the `sim_RVped` function, users will set:

1. `num_affected` = 2
2. `ascertain_span` = c(2000, 2015)
3. `stop_year` = 2015
4. `RR` = 10
5. `recall_probs` = c(1)
6. `founder_byears` = c(1900, 1980)

Additionally, the user will need to specify:

1. `onset_hazard`: the population age-specific hazard rate for lymphoid cancer.
2. `death_hazard`: a data frame with 2 columns:
   1. `death_hazard[,1]`: the age-specific hazard rate for death in the unaffected population, i.e. individuals who have NOT had lymphoid cancer.
   2. `death_hazard[,2]`: the age-specific hazard rate for death in the affected population, i.e. individuals who have had lymphoid cancer.
3. `part`: a partition of ages over which to apply the age-specific hazard rates in `onset_hazard` and `death_hazard`.

For individuals studying lymphoid cancer in the United States, the age-specific hazard rates of lymphoid cancer and of death in the affected population may be estimated by a program such as the Surveillance, Epidemiology, and End Results Program (SEER) [4].  Furthermore, since death by lymphoid cancer accounts for a relatively small proportion of all death causes in the general population, the user may choose to approximate the hazard rates of death in the unaffected population by the age-specific hazard rates of death in the general population, which can be estimated from actuarial life tables provided by the Social Security Administration [5].

For the sake of illustration, suppose that the family study in the example was conducted in the United States.  The `AgeSpecific_Hazards` data set included with the `SimRVPedigree` package contains age-specific hazard rates which were generated to roughly mimic those required for lymphoid cancer onset in the United States as described above.  The three columns in the `AgeSpecific_Hazards` data set provide the required age-specific hazard rates, in yearly increments, beginning at age 0 and ending with age 100.  That is, the values in the first row describe the hazard rates for an individual whose age is contained in the interval [0, 1), while the values in the second row describe the hazard rates for an individual whose age is contained in the interval [1, 2), and so on.  For more information on the `AgeSpecific_Hazards` data set type the command `help(AgeSpecific_Hazards)` into the `R` console.

After installing the `SimRVPedigree` package, we load it by typing the command:

```{r}
library(SimRVPedigree)
```

Next, we load the age-specific hazard rates for this application as follows:

```{r}
#load example hazards 
data("AgeSpecific_Hazards")

#print column names 
colnames(AgeSpecific_Hazards)
```

Looking at the output above, we can see that when we call `sim_RVped()`, we will set the `onset_hazard` argument to the first column in the `AgeSpecific_Hazards` data set, and the `death_hazard` argument will be set to the second and third columns (in that order) of the `AgeSpecific_Hazards` data set.  Since the `AgeSpecific_Hazards` data set supplies the age specific hazard rates in yearly increments starting at age 0 and ending with age 100, we will define our partition to feed to the `part` argument of `sim_RVped` as follows:

```{r}
# Specify age partition.
age_part <- seq(0, 100, by = 1)
```

Let's quickly plot the age-specific hazard rates against the ages they apply to.

```{r, fig.width = 7, fig.height = 4, eval = F}
# plot age-specific hazard rates in the AgeSpecific_Hazards dataset
par(mfrow = c(1, 2), mar = c(5.1, 5.1, 4.1, 2.1))
# plot age-specific hazard rate of disease by age
plot(x = seq(0, 99, by = 1), y = AgeSpecific_Hazards[,1],
     xlab = "Age (in years)", ylab = "Hazard Rate of Disease", 
     main = "Hazard Rate of Disease by Age", 
     ylim = c(0, 0.002), col = "red3", lwd = 2, type = "s")
# plot age-specific hazard rate of death by age
plot(x = seq(1, 100, by = 1), y = AgeSpecific_Hazards[,3],
     xlab = "Age (in years)", ylab = "Hazard Rate of Death",
     main = "Hazard Rate of Death by Age", 
     col = "goldenrod2", ylim = c(0, 1), lwd = 2, type = "s")
lines(x = seq(1, 100, by = 1), y = AgeSpecific_Hazards[,2],
     col = "dodgerblue", lwd = 2, type = "s")
# create legend to detail population type
legend("topleft", title = "Population", legend = c("General", "Affected"),
       col = c("dodgerblue", "goldenrod2"), lwd = 2)
# reset plot defaults
par(mfrow = c(1, 1))
```

Finally, we show how `sim_RVped()` may be used to simulate a single family ascertained for study in the example described at the beginning of this section.

```{r}
# Simulate a random pedigree 
set.seed(3)
ex_RVped <- sim_RVped(onset_hazard = AgeSpecific_Hazards[,1],
                      death_hazard = AgeSpecific_Hazards[,c(2,3)],
                      part = age_part,
                      num_affected = 2,
                      ascertain_span = c(2000, 2015),
                      RR = 10, stop_year = 2015,
                      recall_probs = c(1),
                      founder_byears = c(1900, 1980),
                      FamID = 1)

```

The `sim_RVped` returns a list of two data frames.  The first data frame, named `full_ped`, represents the original pedigree prior to proband selection and trimming.  The second data frame, named `ascertain_ped`, represents the ascertained pedigree, and includes an additional variable to identify the proband.  Any relatives not recalled by the proband are removed from the ascertained pedigree.  If a relative is not recalled by the proband, but is required to plot the pedigree using the `kinship2` package [6], they are included in the ascertained pedigree, but their information is missing, and they are be labelled as unavailable.  

Since we are interested in families that were ascertained for study, we will focus on the `ascertain_ped` data frame returned by the `sim_RVped()` function.  Let's look at the information that is contained in this data frame.

```{r}
# store the second data frame, i.e. the ascertained pedigree, 
# returned by the sim_RVped() function
studyPed <- ex_RVped[[2]] 

# Print first three rows of 
head(studyPed, n = 3)
```
The columns in the data frame above may be described as follows:

 1. `FamID`: family identification number 
 2. `ID`: individual identification number
 3. `gender`: gender identification variable: `gender = 0` for males, and `gender = 1` females. 
 4. `dad_id`: identification number of father
 5. `mom_id`: identification number of mother
 6. `affected`: affection status: `affected = 1` if individual has developed lymphoid cancer, and 0 otherwise.
 7. `DA1`: paternally inherited allele at the assumed disease locus: `DA1 = 1` if rare variant is present, and 0 otherwise.
 8. `DA2`: maternally inherited allele at the assumed disease locus: `DA2 = 1` if rare variant is present, and 0 otherwise.
 9. `birth_year`: the individual's birth year.
 10. `onset_year`: the individual's year of disease onset, when applicable.
 11. `death_year`: the individual's year of death, when applicable.
 12. `RR`: the individual's relative risk of disease.
 13. `available`: availability status: `available = 1` if individual is recalled by proband, otherwise `available = 0`.  We note that, by default, all marry-ins are unavailable since we do not simulate life events for marry-ins.
 14. `Gen`: the individual's generation number relative to the founder who introduced the rare variant.  That is, the founder who introduced the rare variant will have `Gen = 1`, his or her offspring will have `Gen = 2`, etc.  
 15. `proband`: a proband identifier: `proband = 1` if the individual is the proband, and 0 otherwise.

Next, we will illustrate how to plot simulated pedigrees using the `kinship2` package.

```{r, results = FALSE, tidy = TRUE, echo = TRUE, message=FALSE}
# Pedigrees may be plotted using the kinship2 package.  Assuming the
# package has been installed it is loaded by executing the command:
 library(kinship2)
```

```{r, fig.height = 5, fig.width = 7}
# Define a pedigree object by passing all the required information 
# about the ascertained pedigree, which we stored as 'studyPed', 
# to kinship2's pedigree() function.
 ex_RVpedigree <- pedigree(id = studyPed$ID,
                           dadid = studyPed$dad_id,
                           momid = studyPed$mom_id,
                           sex = (studyPed$gender + 1),
                           affected = cbind(Affected = studyPed$affected,
                                            Proband = studyPed$proband,
                                            RV_status = studyPed$DA1 + 
                                                        studyPed$DA2),
                           status = ifelse(is.na(studyPed$death_year), 0, 1))


 # Plot pedigree by passing the pedigree object to the plot() function.
 plot(ex_RVpedigree)

 # Plot legend for shading variables.
 pedigree.legend(ex_RVpedigree, location = "topleft",  radius = 0.25)
```

Often, there is additional individual information we would like to display along with the pedigree.  For example: an individual's age of onset, and their age or, if death has occurred, their age at death when the study ended.  The following code illustrates how we could annotate the pedigree above to include this information.

```{r, fig.height = 7, fig.width = 7}
# Since the study ended in 2015, let's create an age label for individuals 
# for whom we have a year of birth and who haven't died by 2015.
Age2015 <- ifelse(is.na(studyPed$birth_year) | !is.na(studyPed$death_year), 
                     " ", paste0("\n age: ", 2015 - studyPed$birth_year))

# Create a death age label for individuals who have died by 2015.
DeathAge2015 <- ifelse(is.na(studyPed$death_year), 
                   " ", paste0("\n death age: ", 
                               studyPed$death_year - studyPed$birth_year))

# Create an onset age label for individuals who experienced onset by 2015.
OnsetAge2015 <- ifelse(is.na(studyPed$onset_year), 
                   " ", paste0("\n onset age: ", 
                               studyPed$onset_year - studyPed$birth_year))

# Plot pedigree with new id labels that reflect pedigree ages in 2015.
plot(ex_RVpedigree, cex = 0.9, 
     id = paste0("ID: ", sep = "", studyPed$ID,
                 Age2015, OnsetAge2015, DeathAge2015),
     mar = c(1.1, 3.1, 5.1, 2.1))
# Plot pedigree legend.
pedigree.legend(ex_RVpedigree, location = "topleft", radius = 0.25)
mtext("Calendar Year 2015", side = 3, line = 1)
```

It is important to note that the pedigree above may have looked quite different at the time of ascertainment.  Recall that, for pedigrees simulated with `sim_RVped()`, ascertainment of the pedigree is assumed to occur during the same calender year that the proband experienced disease onset.  We can determine what year the pedigree above was ascertained using the following commands.

```{r}
# Determine ascertainment year by viewing the proband's year of disease onset.
studyPed$onset_year[which(studyPed$proband == 1)]
```

From the output above we see that the example pedigree was ascertained in 2005.  To view the pedigree as it would have appeared at the time of ascertainment, we can use the `censor_ped()` function to censor all events that occurred after 2005.  The following code illustrates this process.

```{r, fig.height = 6.5, fig.width = 7}
# First, we censor all events that occurred after 2005. 
Ped2005 <- censor_ped(ped_file = studyPed, censor_year = 2005)

# Next, create new lables for the censored pedigree.
# This time we first create age labels for individuals for whom we know
# the year of birth and who hadn't died by 2005.
Age2005 <- ifelse(is.na(Ped2005$birth_year) | !is.na(Ped2005$death_year),
                  " ", paste0("\n age: ", 2005 - Ped2005$birth_year))

# Next, we create a death age label for individuals who had died by 2005
DeathAge2005 <- ifelse(is.na(Ped2005$death_year), 
                       " ", paste0("\n death age: ", 
                                   Ped2005$death_year -  Ped2005$birth_year))

# Finally, we create an onset age label for individuals who had 
# experienced disease onset by the year 2005.
OnsetAge2005 <- ifelse(is.na(Ped2005$onset_year), 
                       " ", paste0("\n onset age: ",
                                   Ped2005$onset_year - Ped2005$birth_year))

# To plot the pedigree as it appeared in 2005, we must define a new pedigree 
# object for the 2005 pedigree.  Since there are different ways to define a 
# pedigree object, for variety, this time we'll do it a bit differently and use
# the with() function to pass the censored pedigree to the pedigree() function.
Censored_Ped <- with(Ped2005, 
                     pedigree(id = ID,
                              dadid = dad_id,
                              momid = mom_id,
                              sex = (gender + 1),
                              affected = cbind(Affected = affected,
                                               Proband = proband,
                                               RV_status = DA1 + DA2),
                              status = ifelse(is.na(death_year), 0, 1)))

# Plot pedigree with d labels updated to reflect the pedigree in 2005.
plot(Censored_Ped, cex = 0.9, 
     id = paste0("ID: ", sep = "", Ped2005$ID,
                 Age2005, OnsetAge2005, DeathAge2005),
     mar = c(1.1, 3.1, 5.1, 2.1))

# Plot the pedigree legend 
pedigree.legend(Censored_Ped, location = "topleft", radius = 0.25)
mtext("Calendar Year 2005", side = 3, line = 1)
```

Looking at the pedigree above, we see that in 2005, only 2 family members had experienced onset of lymphoid cancer, both of whom were alive.  Referring to the 2015 pedigree, we see that both individuals who were affected in 2005 have died by 2015.  Additionally, we see that nine years after the pedigree was ascertained the proband's sister (the pedigree member whose ID is 5) also experienced onset of lymphoid cancer.


Occasionally, it is of interest for researchers to assign generation numbers among affected family members that reflect their distance from the most recent common ancestor with whom all could share a variant identical by descent (IBD).  For example, consider a family with two affected members.  If the two affected members are a parent and an offspring, then the parent would be assigned generation 1 and the offspring generation 2.  If instead, the two affected members were a pair of siblings, each would be assigned generation 2, since their parents would represent generation 1.  The `assign_affectedGen` function provided with the `SimRVPedigree` package may be used to accomplish this task.  We illustrate the behavior of this function by applying it to two of the five pedigrees included in the `EgPeds` data set. 


```{r, fig.height = 5.5, fig.width = 7}
# We load the EgPeds dataset with the command
data(EgPeds)

# Next, we use kinship2's pedigree function to assign these 
# pedigrees to a pedigree object.
eg_peds <- with(EgPeds, pedigree(famid = FamID,
                                 id = ID,
                                 dadid = dad_id,
                                 momid = mom_id,
                                 sex = gender + 1,
                                 affected = affected))
eg_peds

# Let's re-assign the generation numbers among the affected members for the 
# two of the pedigrees in this dataset, the pedigrees with FamID = 1 and 5, 
# and store them as RAG_peds
RAG_peds <- rbind(assign_affectedGen(EgPeds[which(EgPeds$FamID == 1), ]),
                  assign_affectedGen(EgPeds[which(EgPeds$FamID == 5), ]))

# Create pedigree object for pedigrees with reassigned generation numbers
Rpeds <- with(RAG_peds, pedigree(famid = FamID,
                                 id = ID,
                                 dadid = dad_id,
                                 momid = mom_id,
                                 sex = gender + 1,
                                 affected = affected))

# Create new id labels that merge the individual IDs with their 
# generation numbers, so that we can compare the generation numbers
ID1 = paste0("ID", sep = ":",
             EgPeds[which(EgPeds$FamID == 1), 2],
             sep = "\n Gen:", EgPeds[which(EgPeds$FamID == 1), 14])

ID2 = paste0("ID", sep = ":",
             RAG_peds[which(RAG_peds$FamID == 1), 2],
             sep = "\n Gen:", RAG_peds[which(RAG_peds$FamID == 1), 14])

# Plot pedigrees before and after reassigning
# generation number based on affcted status
par(mfrow = c(1,2))
plot(eg_peds['1'], id = ID1, mar = c(2, 1, 4, 2))
mtext("Pedigree 1: Before", side = 3, line = 1, cex = 1.15)

plot(Rpeds['1'], id = ID2, mar = c(2, 2, 4, 1))
mtext("Pedigree 1: After", side = 3, line = 1, cex = 1.15)
```

Looking at the before and after for this pedigree, the most striking observation is the reduction of the pedigree to include only affected members, their parents, and common ancestors.  Additionally, we see that the generation numbers of the affected members have not changed.  This is because the most recent common ancestors of the affected individuals (IDs 6, 8, and 15) are the two eldest founders (IDs 1 and 2).  Since the focus of this assignment scheme is on the affected members, all other family members are now missing generation numbers in the rightmost plot, labelled "after".

```{r, fig.height = 5.5, fig.width = 7}
#Repeat same steps as before, this time for the pedigree with FamID = 5
#First, create some new id lables that merge the individual IDs with 
#their generation numbers.
ID1 = paste0("ID", sep = ":",
             EgPeds[which(EgPeds$FamID == 5), 2],
             sep = "\n Gen:", EgPeds[which(EgPeds$FamID == 5), 14])

ID2 = paste0("ID", sep = ":",
             RAG_peds[which(RAG_peds$FamID == 5), 2],
             sep = "\n Gen:", RAG_peds[which(RAG_peds$FamID == 5), 14])

# Plot pedigrees before and after reassigning
# generation number based on affcted status
par(mfrow = c(1,2))
plot(eg_peds['5'], id = ID1, mar = c(2, 1, 4, 2))
mtext("Pedigree 5: Before", side = 3, line = 1, cex = 1.15)

plot(Rpeds['5'], id = ID2, mar = c(2, 2, 4, 1))
mtext("Pedigree 5: After", side = 3, line = 1, cex = 1.15)
```

In this example, in the leftmost pedigree, we see a pair of affected cousins (IDs 15 and 33).  Therefore, in the rightmost pedigree, each of the cousins is assigned generation 3, since the most recent common ancestors of the affected cousins are their common grandparents (IDs 3 and 9).


#6. Parallel Processing Example<a name="ParProcExample"></a>
It is important to note that the processing time required to simulate a sample of pedigrees ascertained for multiple affected members is directly related to (1) the rarity of the disease, and (2) arguments specified by the user.  In particular, we expect to see an increase in the required computation time as: 

 1. the relative risk, `RR`, specified by the user approaches 1, particularly for rare diseases,
 2. the ascertainment period, `ascertain_span`, narrows,
 3. the proband's relative recall probabilities, `recall_probs`, become smaller.

For details concerning any of the arguments of the `sim_RVped()` function please refer to section 3.

To illustrate the effect of the relative risk argument on the time required to simulate a study sample of 150 families for the family-study described in section 5, the following table lists the average computation times, in hours, observed over repeated simulations on a Windows OS with an i7-4790 @ 3.60 GHz, 12 GB of RAM, and a C220 SATA AHCI.

Relative Risk | Average Computation Time (in hours) | Number of trials
------------- | ------------------------------------|-----------------
1 | 9.72 | 20
5 | 1.15 | 15
10 | 0.44 | 18
15| 0.28 | 13
20 | 0.18 | 17

Other combinations of simulation settings could also result in longer computation times.  For this reason, when possible, we recommend the use of parallel processing to simulate a large number of pedigrees ascertained for multiple affected members.  

The following parallel processing example uses the `doParallel` [3] and `doRNG` [1] packages to simulate an entire study sample of 150 pedigrees for the family-based study described in section 5.  The following code has been tested on both Windows and Macintosh operating systems, however, slight modifications may be necessary for users working other operating systems. 

```{r, eval = FALSE}
#Note that: while parallel processing may achieved using only the doParallel 
#package, to ensure that simulations are reproducible we must also incorporate 
#the doRNG package.

#assuming they have been installed, the required packages are loaded using the 
#commands:
library(doParallel)
library(doRNG)

# Before we create our cluster, let's determine how many processors are 
#currently in use using the getDoParWorkers function.  Since we have not created
#a cluster yet, this function should return 1.
getDoParWorkers()

#The number of cores available for parallel processing will depend on the the 
#computer.  To determine how many cores are available on your computer,  
#execute the following command:
detectCores()

#To run simulations in parallel we must create a cluster and then register the 
#cluster. The following code illustrates how to create and register a cluster 
#that will run simulations in parallel on 2 cores.      
cl <- makeCluster(2)       # create cluster
registerDoParallel(cl)     # register cluster

#Now that we have set up our cluster, getDoParWorkers() should return 2 instead of 1
getDoParWorkers()

#To avoid problems, after you are finished using the cluster, you will want to 
#stop it. This can be achieved by executing the following:
on.exit(stopCluster(cl))
#on.exit(stopCluster(cl)) automatically stops the cluster when you end the R 
#session.  Alternatively, you could execute the command stopCluster(cl) after 
#the simulation is complete.


#To ensure reproducibility, we make use of the %dorng% operator provided by the 
#doRNG packag in the foreach loop, by specifing a random-number seed after .option.RNG.
npeds <- 150    #set the number of pedigrees to generate
RV_peds = foreach(i = seq(npeds),   
                  .combine = rbind,  
                  .packages = c("kinship2", "SimRVPedigree"),  
                  .options.RNG = 1984
                  ) %dorng% {
                    sim_RVped(onset_hazard = AgeSpecific_Hazards[,1],
                              death_hazard = AgeSpecific_Hazards[,c(2,3)],
                              part = seq(0, 100, by = 1),
                              num_affected = 2,
                              ascertain_span = c(1900, 2015),
                              RR = 5, stop_year = 2015,
                              recall_probs = c(1),
                              founder_byears = c(1900, 1910),
                              FamID = i)[[2]]
                    }
```


#7. References <a name="Ref"></a>
[1] Renaud Gaujoux (2014). 
  **doRNG: Generic Reproducible Parallel Backend for foreach Loops.** 
  *R package version 1.6.*
  https://CRAN.R-project.org/package=doRNG
  
[2] Ken-Ichi Kojima, Therese M. Kelleher. (1962), 
  **Survival of Mutant Genes**. 
  The American Naturalist 96, 329-346. 

[3] Revolution Analytics and Steve Weston (2015).
  **doParallel: Foreach Parallel Adaptor for the 'parallel' Package.** 
  *R package version 1.0.10.*
  https://CRAN.R-project.org/package=doParallel

[4] The Surveillance, Epidemiology, and End Results (SEER) Program.  Retrieved on 24 October 2016 from \url{http://seer.cancer.gov/}

[5] Social Security Administration. Life Tables for the United States Social Security Area 1900-2100. Retrieved on 24 October 2016 from \url{https://www.ssa.gov/oact/NOTES/as120/TOC.html}

[6] Terry M Therneau and Jason Sinnwell (2015).
  **kinship2: Pedigree Functions.** 
  *R package version 1.6.4.* 
  https://CRAN.R-project.org/package=kinship2

[7] Thompson, E. (2000). 
  *Statistical Inference from Genetic Data on Pedigrees*. 
  NSF-CBMS Regional Conference Series in Probability and Statistics, 6, I-169.
  Retrieved from http://www.jstor.org.proxy.lib.sfu.ca/stable/4153187

[8] Ellen M. Wijsman (2012). 
  *The role of large pedigrees in an era of high-throughput sequencing*. 
  Hum Genet 131, 1555-1563 
