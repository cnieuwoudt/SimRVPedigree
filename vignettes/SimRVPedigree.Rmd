---
title: "SimRVPedigree"
author: "Christina Nieuwoudt, Jinko Graham"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{SimRVPedigree}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body{ /* Normal  */
   font-size: 20px;
}
</style>

# Table of contents
1. [Introduction](#introduction)
2. [Individual and Pedigree Specific Assumptions](#PedLevel)
3. [Study Design/Ascertainment Scheme Features](#StudyLevel)
4. [Example Application](#Example)
5. [Parallel Processing Example](#ParProcExample)


# Introduction <a name="introduction"></a>
Family-based studies designed to identify genetic susceptibility factors associated with rare diseases have received significant consideration in recent years.  Due to the rarity of the diseases under consideration, in some cases, garnering a suitable number of families for analysis could require decades of continued collaboration between researchers and clinicians.  Understandably, due to the nature of these studies, they are inherently difficult and sometimes infeasible to replicate.  The `SimRVPedigree` package aims to address this problem by providing a platform to randomly simulate pedigrees similar to those ascertained  for family-based studies to contain multiple relatives affected with a rare disease.

The distinguishing feature of the `SimRVPedigree` packages is that it simulataneously aims to accurately mimic the process of family development, while allowing users to incorporate multiple facets of a particular acsertainment scheme.  To illustrate and fully explain these features, in the next two sections, we will first discuss assumptions governing the process of pedigree simulation, followed by a full exposition of the study design features available to users.  Later we provide an example, which illustrates an application of `SimRVPedigree` to simulate pedigrees for a specific family-based study.

#Individual and Pedigree Specific Assumptions <a name="PedLevel"></a>
1. Given a sample of pedigrees we allow for the possibility that different families may segregate different rare variants, but make the assumption that within a family genetic cases are due to a shared rare variant that increases disease susceptibility.

2. We assume that the variant is rare enough that it has been introduced by at most one founder.  We begin the simulation of the pedigree with this founder, and transmit the rare variant from parent to offspring according to Mendel's laws.

3. We assume that the age-specific hazard for disease onset follows a Cox proportional hazards model.  Under this model, individuals who have NOT inheritied the rare variant (i.e. sporadic cases) experience disease onset according to the baseline (or population) disease onset hazard.  On the other hand, individuals who have inherited the rare variant (i.e. genetic cases),  are assumed to have an increased relative risk of diesease onset.  The user is expected to supply the baseline disease onset hazard, as well as the relative risk of disease onset for genetic cases.  

4. We assume that unaffected individuals experience death according to the age-specific death hazard of the unaffected population, which is provided by the user.  If the disease of interest is rare enough, the user may substitute the 
population age-specific death hazard in place of the unaffected age-specific death hazard.  We assume that affected individuals experience death according to the age-specific death hazard of the affected population, also provided by the user.  

5. We do not model disease remission, or second onset events.  That is, we impose the restriction that individuals who experience disease onset may only do so once.  Furthermore, after onset has occured the affected death hazard is always used to simulate the death event, i.e. we do not switch back to using the unaffected death hazard after a specified number of years.

<!-- NOTE: Our assumption that genetic cases share the same relative risk parameter across families is not imposed upon the user.  Since the top level function only simulates a single pedigree (we decided to do this so that users could efficiently implement parallel processing) the user could choose to simulate a study sample containing families with different relative risks.   -->

#Study Design/Ascertainment Scheme Features <a name="PedLevel"></a>
 In particular pedigrees simulated with `sim_RVpedigree` will reflect that ascertainment occurs over a user-specified time-period, and is through a proband.  Incomplete ascertainment of families may be modelled through proabnd recall probabilites of relatives.  

#Example Application <a name="Example"></a>
In this section we provide an example of a family-based study that could be simulated using `SimRVPedigree`.

Suppose that from 2000 to 2015, a group of researchers, in collaboration with a team of clinicians, have been collecting data on families that contain at least two, related individuals who are affected by a lymphoid cancer.  





After installing the `SimRVPedigree` package, load it by typing the command:
```{r}
library(SimRVPedigree)
```

`SimRVPedigree` includes 2 datasets:
 
 1. `AgeSpecific_Hazards`: A dataset containing sample age-specific hazards.
 2. `exp_peds`: A dataset of five example pedigrees.

All of the functions in the `SimRVPedigree` package require the user to specify age-specific hazards for diesase onset, death in the unaffected population, and death in the affected population.  The `AgeSpecific_Hazards` data set provides sample age-specific hazards, which we will use for the purpose of illustration.  The `exp_peds` dataset includes 4 pedigrees prior to proband selection.  We will use the `exp_peds` data to illustrate the effects of trimming pedigrees based on a proband's recall probability of a relative, and reassignment of affected generation number to reflect minimum carrier status.  For more information on either of these datasets please type the command `help(AgeSpecific_Hazards)` and/or `help(exp_peds)` in the `R` console. 

### Simulating Pedigrees
Simulation of a full pedigree is accomplished as follows:

1. Simulate the founder's year of birth uniformly from the span of ages specified in `founder_byears`.  We assume that this founder has introduced the rare variant into the pedigree.
2. Simulate all life events for the founder who has introduced the rare variant.
3. Transmit the rare variant to any of the founder's offspring according to Mendel's laws.
4. Simulate life events for all offspring recursively until the `stop_year` or death is reached.  The `stop_year` argument represents the end of the study.  All information that occurs after the stop year is censored. 

Random simulation of a pedigree may be achieved using the `sim_ped` function as illustrated below.
```{r}
#load example hazards 
data("AgeSpecific_Hazards")
colnames(AgeSpecific_Hazards)

#the first column of the AgeSpecific_Hazards dataset provides the age-specific
#onset hazard for the population
my_onset_hazard = AgeSpecific_Hazards[,1]

#the second and third columns of the AgeSpecific_Hazards dataset, respectively,
#provide the age-specific death hazards for the unaffected and affected 
#populations.  Note: if the disease of interest is sufficiently rare the 
#population death hazard may be used as an estimate for the unaffected death 
#hazard.
my_death_hazard <- AgeSpecific_Hazards[, c(2,3)]

#We must specify a partition of ages over which to apply the age-specifc
#hazards.  Note that a valid partition must contain 1 element more that the
#age-specific hazards. The age-specific hazards in AgeSpecific_Hazards are specified 
#in 1 year increments starting at birth, thus we can specify the partition of ages by 
age_part = seq(0, length(my_onset_hazard), by = 1)  

```
```{r}
 #Simulate a random pedigree
 set.seed(6)
 ex_ped <- sim_ped(onset_hazard = my_onset_hazard,
                   death_hazard = my_death_hazard,
                   part = age_part, stop_year = 2015,
                   RR = 5, FamID = 1,
                   founder_byears = c(1900, 1910))
```
```{r, results = FALSE, tidy = TRUE, message = FALSE}
# Pedigrees may be plotted usign the kinship2 package.  Assuming that 
# this package has been installed it is loaded by executing the command:
 library(kinship2)
```
```{r, fig.height=4, fig.width=6}
# Define pedigree to use kinship2's plot function
 ex_pedigree <- pedigree(id = ex_ped$ID,
                         dadid = ex_ped$dad_id,
                         momid = ex_ped$mom_id,
                         sex = (ex_ped$gender + 1),
                         affected = cbind(Affected = ex_ped$affected,
                                          RV_status = ex_ped$DA1 + 
                                                      ex_ped$DA2),
                         famid = ex_ped$FamID)['1']
 plot(ex_pedigree, cex = 0.75)
 pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
```

Is it critical to note that the `sim_ped` function does not simulate pedigrees with a mimimum number of affected individuals.  Furthermore, if the pedigree founder does not produce any offspring `sim_ped` will return a ped file with a single individual.  To ensure that a simulated pedigree contains a minimum number of affected individuals please use the `sim_RVpedigree` function.

### Trimming Pedigrees
One of the features included in the the `SimRVPedigree` package is the option to trim pedigrees based on a proband's ability to recall relatives.  This option is included to allow researchers to model the ascertainment bias that occurs when individuals either cannot provide a complete family history or they explicity request that particular family members not be contacted.

To trim a pedigree the user must specify:

1. `recall_probs`: the proband's relative recall probabilities, $p = (p_1, p_2, ..., p_n)$ where $$\rho_i = \left\{ \begin{array}{ll}
                \text{proband recall probability for a relative of degree } i & \text{for } i < n;\\
                \text{proband recall probability for a relative of degree $n$ or greater} & \text{for } i = n.\end{array} \right.$$
                To simulate fully ascertained families simply specify `recall_probs = c(1)` so that the proband's recall probability of all relatives is 1. 
2. `ascertain_span`: the ascertainment period in years.  This period represents the range of years during which the proband developed disease and the family would have been ascertained for multiple affecteds. 
3. `num_affected`: the minimum number of affected individuals in the pedigree at the time of ascertainment.  NOTE: this does not ensure that  after trimming the pedigree will contain at least `num_affected` individuals, it only ensures that the proband is chosen so that at least `num_affected`- 1 indivdiuals in the family were affected before the proband experienced onset. 

The following results illustrate how various arguement settings affect the `trim_ped`.  Let's begin the example by considering the following pedigree prior to the application of `trim_ped`:

```{r, fig.height = 4.55, fig.width=7, echo = FALSE}
 #Read in example pedigree to trim
 data(exp_peds)

 #plot first pedigree in example_ped using kinship2
 library(kinship2)
 ex_pedigree <- pedigree(id = exp_peds$ID,
                         dadid = exp_peds$dad_id,
                         momid = exp_peds$mom_id,
                         sex = (exp_peds$gender + 1),
                         affected = cbind(Affected = exp_peds$affected,
                                          RV_status = exp_peds$DA1 +
                                                      exp_peds$DA2),
                         famid = exp_peds$FamID)['1']
 plot(ex_pedigree, cex = 0.85)
 pedigree.legend(ex_pedigree, location = "topleft",  radius = 0.25)
 mtext("Original Pedigree", side = 3, line = 2)
```

Notice that, with the exception of proband selection, the following trimmed pedigree is identical to the original pedigree.  This is accomplished by setting `recall_probs = c(1)`.

```{r, echo = FALSE, results = FALSE, eval = TRUE, fig.height=4.5, fig.width=7}
set.seed(2)
#trim pedigree
TrimPed <- trim_pedigree(ped_file = exp_peds[which(exp_peds$FamID == 1), ],
                             ascertain_span = c(2005, 2015),
                             num_affected = 2,
                             recall_probs = c(1))

#plot trimmed pedigree
Tped <- pedigree(id = TrimPed$ID,
                 dadid = TrimPed$dad_id,
                 momid = TrimPed$mom_id,
                 sex = (TrimPed$gender + 1),
                 affected = cbind(Affected = TrimPed$affected,
                                  Proband = TrimPed$is_proband,
                                  RV_status = TrimPed$DA1 + TrimPed$DA2),
                 famid = TrimPed$FamID)['1']

plot(Tped, cex = 0.85)
pedigree.legend(Tped, location = "topleft",  radius = 0.25)
mtext("recall_probs = c(1), \n ascertain_span = (2005, 2015), \n num_affected = 2",
      side = 3 )
```

In the next example the original pedigree has been trimmed after setting the proband recall probabilities to `recall_probs = c(1, 0.5, 0.25, 0.125)`. 

```{r, echo = FALSE, results = FALSE, eval = TRUE, fig.height=4.55, fig.width=7}
set.seed(2)
#trim pedigree
TrimPed <- trim_pedigree(ped_file = exp_peds[which(exp_peds$FamID == 1), ],
                             ascertain_span = c(2005, 2015),
                             num_affected = 2,
                             recall_probs = c(1, 0.5, 0.25, 0.125))

#plot trimmed pedigree
Tped <- pedigree(id = TrimPed$ID,
                 dadid = TrimPed$dad_id,
                 momid = TrimPed$mom_id,
                 sex = (TrimPed$gender + 1),
                 affected = cbind(Affected = TrimPed$affected,
                                  Proband = TrimPed$is_proband,
                                  RV_status = TrimPed$DA1 + TrimPed$DA2),
                 famid = TrimPed$FamID)['1']

plot(Tped, cex = 0.85)
pedigree.legend(Tped, location = "topleft",  radius = 0.25)
mtext("recall_probs = c(1, 0.5, 0.25, 0.125), \n ascertain_span = (2005, 2015), \n num_affected = 2",
                 side = 3 )
```

If `recall_probs` is left unspecified, the `trim_ped` function will automatically use the 4*kinship coeffient between the proband and his or her relatives as the recall probability.  This has the effect of retaining all first degree relatives with probability 1.

### Simulating Pedigrees with Multiple Affecteds
Simulation of pedigrees likely to be ascertained according to a particular study design is the primary purpose of the `SimRVPedigree` package and is accomplished with the `sim_RVpedigree` function.  

To simulate a pedigree with `sim_RVpedigree` the user must specify:

1. `onset_hazard`: the population age-specific disease onset hazard.
2. `death_hazard`: a data frame with:
     1. column 1: the unaffected age-specific death hazard,
     2. column 2: the affected age-specific death hazard.
   If the disease of interest is sufficiently rare, the unaffected age-specific death hazard my be approximated by the population age-specific death hazard.
3. `part`: a partition of ages over which to apply the age-specific hazard in `onset_hazard` and `death_hazard`.
4. `RR`: the relative risk of diesase onset for indivdiuals who have inherited the rare variant. 
5. `FamID`: the family ID to assign to the simuated pedigree.
6. `founder_byears`: the span of years from which to simulate, uniformly, the founder's birth year.
7. `ascertain_span`: the ascertainment period in years.  This period represents the range of years during which the proband developed disease and the family would have been ascertained for multiple affecteds. 
8. `num_affected`: the minimum number of affected individuals in the pedigree. 

Optional arguments:

9. `recall_probs`: the proband's relative recall probabilities, if unspecified 4*kinship coeffient between the proband and the relative will be used.
10. `birth_range`: the minimum and maximum allowable ages indivduals will be able to reproduce.  If unspecified it is assumed that `birth_range = c(18, 45)`. 
11. `NB_params`: the size and probability parameters of the negative binomial distribution used to model the number of children per household. If unspecifed it is assumed that `NB_params = c(2, 4/7)`.
12. `stop_year`: the last year of study.  If unspecified the current year will be used.

```{r}
#Load hazard data
data(AgeSpecific_Hazards)

#specify onset hazard, death hazard, and age parition over which to apply 
#hazards.
my_onset_hazard <- AgeSpecific_Hazards[,1]
my_death_hazard <- AgeSpecific_Hazards[,c(2,3)]
age_part <- seq(0, 100, by = 1)

 #Simulate a random pedigree
 set.seed(6)
 ex_RVped <- sim_RVpedigree(onset_hazard = my_onset_hazard,
                            death_hazard = my_death_hazard,
                            part = age_part,
                            RR = 5, FamID = 1, stop_year = 2015,
                            founder_byears = c(1900, 1910),
                            ascertain_span = c(1900, 2015),
                            num_affected = 2,
                            recall_probs = c(1, 0.5, 0.25, 0.125))
```

The `sim_RVpedigree` returns two data frames, which are plotted below.  The first is the ped file of the original pedigree prior to trimming.  The second is the ascertained pedigree, with proband selected and unrecalled relative removed.  If a relative cannot be recalled by the proband but they are required to create a full pedigree structure they will be readded to the pedigree, but all of their information will be censored.  

```{r, results = FALSE, tidy = TRUE, echo = FALSE, message=FALSE}
#Pedigrees may be plotted usign the kinship2 package.  Assuming that this 
#package has been installed it is loaded by executing the command:
 library(kinship2)
```
```{r, fig.height=5, fig.width=7, echo = FALSE}
 #Define pedigree to use kinship2's plot function
 ex_RVpedigree_FULL <- pedigree(id = ex_RVped[[1]]$ID,
                           dadid = ex_RVped[[1]]$dad_id,
                           momid = ex_RVped[[1]]$mom_id,
                           sex = (ex_RVped[[1]]$gender + 1),
                           affected = cbind(Affected = ex_RVped[[1]]$affected,
                                            RV_status = ex_RVped[[1]]$DA1 + 
                                                        ex_RVped[[1]]$DA2),
                         famid = ex_RVped[[1]]$FamID)['1']
 plot(ex_RVpedigree_FULL)
 pedigree.legend(ex_RVpedigree_FULL, location = "topleft",  radius = 0.25)
 mtext("Pedigree Prior to Trimming and Proband Selection", side = 3)

 #Define pedigree to use kinship2's plot function
 ex_RVpedigree_TRIM <- pedigree(id = ex_RVped[[2]]$ID,
                           dadid = ex_RVped[[2]]$dad_id,
                           momid = ex_RVped[[2]]$mom_id,
                           sex = (ex_RVped[[2]]$gender + 1),
                           affected = cbind(Affected = ex_RVped[[2]]$affected,
                                            Proband = ex_RVped[[2]]$is_proband,
                                            RV_status = ex_RVped[[2]]$DA1 + 
                                                        ex_RVped[[2]]$DA2),
                         famid = ex_RVped[[2]]$FamID)['1']
 plot(ex_RVpedigree_TRIM)
 pedigree.legend(ex_RVpedigree_TRIM, location = "bottomleft",  radius = 0.25)
 mtext("Ascertained Pedigree", side = 3)
```

# Parallel Processing Example<a name="ParProcExample"></a>
It is importatant to note that the processing time required to simulate a sample of pedigrees ascertained for multiple affecteds is directly related to (1) the rarity of the disease, and (2) the arguments specified by the user.  In particular, we expect to see increases in the required computation time as: 

 1. as the relative risk, `RR`, specifed by the user approaches 1, particularly for rare diseases, 
 2. as ascertainment period, `ascertain_span`, narrows,
 3. and as the proband's relative recall probabilities, `recall_probs`, become smaller.
 
Given the vast number of study designs that can be specified, it is likely that there are particular combinations of simulation setting may also lead to an increase in processsing time.  For this reason we HIGHLY recommend the use of parallel processing when simulating a large set of pedigrees ascertained for multiple affected members.  

The following parallel processing example uses the `doParallel` and `doRNG` packages to simulate a study sample of 100 pedigrees.  In this simulation we make the following model assumptions:

1. Pedigrees are ascertained on the basis of containing at least
2 affected members: `num_affected = 2`.
2. Set the relative risk of disease onset for individuals who have inherited the rare variant of 1.5 : `RR = 1.5`.
3. Assume the birth year for the founder who introduced the rare variant is distributed uniformly from 1900 to 1980: `founder_byears  = c(1900, 1980)`
4. Set the ascertainment period, i.e. the years the proband experienced onset and the pedigree was ascertained for multiple affecteds, from 2000 to 2016: `ascertain_span = c(2000, 2015)`. 
5. Assume fully ascertained pedigrees, by assuming that the proband can recall all relatives: `recall_probs = c(1)`.
6. Assume that the study ended in 2015: `stop_year = 2015`
 
We will use the example age-specific hazards provided in the `AgeSpecific_Hazards` dataset.  Notice that since the last age-specific hazard in this dataset applies to individuals between the ages of 99 and 100, the largest age possible in this simulation will be 100.

The following example was intended for Windows and slight modifications may be necessary for Unix-like systems.
```{r, eval = FALSE}
#SITATION FOR DOPARALLEL VIGNETTE?
#Note that: while parallel processsing may acheived using only the doParallel 
#package, to ensure that simulations are reproducible we must also incorporate 
#the doRNG package.

#assuming they have been installed the required packages are loaded using the 
#commands:
library(doParallel)
library(doRNG)

# Before we create our cluster, let's determine how many processors are 
#currently in use using the getDoParWorkers function.  Since we have not created
#a cluster yet, this function should return 1.
getDoParWorkers()

#The number of cores available for parallel processing will depend on the the 
#computer  being used.  To determine how many cores are available for parallel 
#processing on your computer, simply execute the following command:
detectCores()

#To run simulations in parallel we must create a cluster and then register the 
#cluster. The following code illustrates how to create and register a cluster 
#that will simulate pedigrees in parallel on 2 cores.      
cl <- makeCluster(2)       # create cluster
registerDoParallel(cl)     # register cluster

#Note that getDoParWorkers() should now return 2 instead of 1
getDoParWorkers()

#To avoid problems, after you are finished using the cluster, you will want to 
#stop it. This can be acheived by executing:   
on.exit(stopCluster(cl))
#which will stop the cluster when you end the R session, or by executing 
#stopCluster(cl) after the simulation is complete.

#to ensure reproducibility, we make use of the %dorng% operator provided by the 
#doRNG package, in the foreach loop, by specifing a seed after .option.RNG.  
npeds <- 8    #set the number of pedigrees to generate

RV_peds = foreach(i = seq(npeds),   
                  .combine = rbind,  
                  .packages = c("kinship2", "SimRVPedigree"),  
                  .options.RNG = 1984
                  ) %dorng% {
                    sim_RVpedigree(onset_hazard = my_onset_hazard,
                                   death_hazard = my_death_hazard,
                                   part = age_part, RR = 1.5, 
                                   FamID = i, stop_year = 2015,
                                   founder_byears = c(1900, 1980),
                                   ascertain_span = c(2000, 2015),
                                   recall_probs = c(1),
                                   num_affected = 2)[[2]]
                    }
```

### Reassigning Affected Generation
Upon simulating a pedigree, occasionally researchers have reason to reassign generation number based on affected status.

This task can be achieved using the `assign_affectedGen` function.
The `assign_affectedGen` function assigns generation 1 to the first reported affected or the the first obligate carrier.  The following examples illustrate the nature of this function.  

In following example we see that since the first obligate carrier is one of the two individuals in generation 1, the generation assignment does not change.

```{r, echo = FALSE, fig.height=5, fig.width=7}
#Read in example pedigree to trim
data(exp_peds)

library(kinship2)
#assign to pedigree object to show before and after behavior of
#the assign_affectedGen function
ex_pedigree <- pedigree(id = exp_peds$ID,
                        dadid = exp_peds$dad_id,
                        momid = exp_peds$mom_id,
                        sex = (exp_peds$gender + 1),
                        affected = exp_peds$affected,
                        famid = exp_peds$FamID)


#create df to store peds with reassigned generation number
RAG_peds <- exp_peds[1,]
RAG_peds <- RAG_peds[-1,]

for(i in 1:4){
  RAG_peds <- rbind(RAG_peds,
                    assign_affectedGen(exp_peds[which(exp_peds$FamID == i), ]))
}

RAG_pedigrees <-  pedigree(id = RAG_peds$ID,
                           dadid = RAG_peds$dad_id,
                           momid = RAG_peds$mom_id,
                           sex = (RAG_peds$gender + 1),
                           affected = RAG_peds$affected,
                           famid = RAG_peds$FamID)

par(mfrow = c(1, 2))
k = 1
  ID1 = paste0("ID", sep = ":",
               exp_peds[which(exp_peds$FamID == k), 2],
               sep = "\n Gen:", exp_peds[which(exp_peds$FamID == k), 14])
  ID2 = paste0("ID", sep = ":",
               RAG_peds[which(RAG_peds$FamID == k), 2],
               sep = "\n Gen:", RAG_peds[which(RAG_peds$FamID == k), 14])
  plot(ex_pedigree[paste0(k)], id = ID1, cex = 0.5)
  mtext("Pedigree before generation reassignment", side = 3, line = 1)
  plot(RAG_pedigrees[paste0(k)], id = ID2, cex = 0.5)
  mtext("Pedigree after generation reassignment", side = 3, line = 1)
```

Notice that in this example, since only individuals 6 and 7 are affected the first obligate carrier is individual 3 or 4, hence the affecteds are assigned generation 2.

```{r, echo = FALSE, fig.height=5, fig.width=7}
par(mfrow = c(1, 2))
k = 3
  ID1 = paste0("ID", sep = ":",
               exp_peds[which(exp_peds$FamID == k), 2],
               sep = "\n Gen:", exp_peds[which(exp_peds$FamID == k), 14])
  ID2 = paste0("ID", sep = ":",
               RAG_peds[which(RAG_peds$FamID == k), 2],
               sep = "\n Gen:", RAG_peds[which(RAG_peds$FamID == k), 14])
  plot(ex_pedigree[paste0(k)], id = ID1, cex = 0.5)
  mtext("Pedigree before generation reassignment", side = 3, line = 1)
  plot(RAG_pedigrees[paste0(k)], id = ID2, cex = 0.5)
  mtext("Pedigree after generation reassignment", side = 3, line = 1)
```
